{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"source/img/article/tag.png","path":"img/article/tag.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/valine.css","path":"css/valine.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/click_show_text.js","path":"js/click_show_text.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/img/article/container-status.jpg","path":"img/article/container-status.jpg","modified":1,"renderable":0},{"_id":"source/img/article_header/tizi.jpg","path":"img/article_header/tizi.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/earch.jpg","path":"img/header_img/earch.jpg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/article/upload-file.png","path":"img/article/upload-file.png","modified":1,"renderable":0},{"_id":"source/img/article_header/bullon.jpg","path":"img/article_header/bullon.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/xirikui.jpg","path":"img/header_img/xirikui.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"source/img/article/github-pages.png","path":"img/article/github-pages.png","modified":1,"renderable":0},{"_id":"source/img/article/report-meta-date.png","path":"img/article/report-meta-date.png","modified":1,"renderable":0},{"_id":"source/img/header_img/pencil.jpg","path":"img/header_img/pencil.jpg","modified":1,"renderable":0},{"_id":"source/img/pay/wechat_pay.png","path":"img/pay/wechat_pay.png","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/header_img/moutain.jpg","path":"img/header_img/moutain.jpg","modified":1,"renderable":0},{"_id":"source/img/pay/ali_pay.png","path":"img/pay/ali_pay.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/road2.jpg","path":"img/header_img/road2.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/road.jpg","path":"img/header_img/road.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":1,"renderable":0},{"_id":"source/img/article/domain.jpeg","path":"img/article/domain.jpeg","modified":1,"renderable":0},{"_id":"source/img/article/huweihuang_blog.png","path":"img/article/huweihuang_blog.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"1b8454da6f5d5554c585c0ded16f112fbc06fd90","modified":1557671619000},{"_id":"source/CNAME","hash":"873b3e9beb44827b59785fb5ae79b939e4aaa2f9","modified":1555309775000},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1555309775000},{"_id":"themes/huweihuang/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1555309775000},{"_id":"themes/huweihuang/_config.yml","hash":"a17a5aa9e9cbd9de97085ae94121e61b5b78c05e","modified":1555385992000},{"_id":"source/_posts/Hexo博客入门.md","hash":"c4c7fcfcd3cbcd2fe11f766a4bcefafc60cf8fc6","modified":1555385533000},{"_id":"source/_posts/如何定制和管理基于Allure框架的自动化测试报告","hash":"ebcf46ed5d51c22b493bcdcb03894bd2d27a9043","modified":1556269025000},{"_id":"source/_posts/深入理解Docker容器和镜像的核心原理.md","hash":"d1ac080416e9f57b3630576f4bbd63cef311034d","modified":1557800207000},{"_id":"source/_posts/谈一谈软件测试中的测试数据准备.md","hash":"64379420b7a20b7dac61b78c4b16b7ae0297a740","modified":1555571070000},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1555309775000},{"_id":"source/about/index.md","hash":"0a9adcd0af1859688331e5b7be0395a49f39bd51","modified":1555571038000},{"_id":"source/_posts/通过容器化Python web应用了解Docker容器核心功能.md","hash":"1163f62c8a897196e8572a8e156c6610c913de5d","modified":1557706288000},{"_id":"source/img/.DS_Store","hash":"88321456f21ab8e708931a35470614899fbbb940","modified":1557894584000},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1555309775000},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1555309775000},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1555309775000},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1555309775000},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1555309775000},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"b25c71964b3d2db93215df6b411f89bb948c5114","modified":1555309775000},{"_id":"themes/huweihuang/layout/index.ejs","hash":"559daffba672bedd15cd831d112a0dd53cb0576d","modified":1555309775000},{"_id":"themes/huweihuang/layout/page.ejs","hash":"a93b28fe6650e5051fcee659411910bdd039e5dd","modified":1555309775000},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1555309775000},{"_id":"themes/huweihuang/layout/post.ejs","hash":"db94e6e1565c252d8ed87964dacd1d788ce66f1a","modified":1555309775000},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1555309775000},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"eb47421fce5c774c4ac5a6a0fe5b420b7c512a22","modified":1555309775000},{"_id":"source/img/article/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1569217108518},{"_id":"source/img/article/tag.png","hash":"c8632d64d9471009098b84f70273e63037a4e7b8","modified":1555309775000},{"_id":"source/img/header_img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1569217108501},{"_id":"themes/huweihuang/layout/_partial/comments.ejs","hash":"7f0986705157d0c6d24b12563d3810c1748fc0dd","modified":1555328289000},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"f19d731a5e35ba83801516cf522624d9a350eb66","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"9031412ba57d519bd8933f38f6b7f2581f64635e","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"312f61ac8ba4cf0e672a8ad900376e335420ffd4","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"f6f1ac0fbcb362546e37a35d6cb362f69fc5f0af","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/recommend_posts.ejs","hash":"0542f6c509e5119037465fdd91bc65bc18a96288","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1555309775000},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1555309775000},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1555309775000},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1555309775000},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1555309775000},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1555309775000},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1555309775000},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1555309776000},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1555309776000},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1555309776000},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1555309776000},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1555309776000},{"_id":"themes/huweihuang/source/css/valine.css","hash":"f34d711b338412297fe0adb79353b792e053392c","modified":1555309776000},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1555309776000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1555309776000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1555309776000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1555309776000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1555309776000},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1555309776000},{"_id":"themes/huweihuang/source/js/click_show_text.js","hash":"f69402c056813cc30e98a4eaa27687807c307c48","modified":1555309776000},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1555309776000},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1555309776000},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1555309776000},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1555309776000},{"_id":"themes/huweihuang/source/js/smoothscroll.js","hash":"134a1ad40b68efec27575a2cdd48eccf8a63bf71","modified":1555309776000},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1555309776000},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1555309776000},{"_id":"source/img/article/container-status.jpg","hash":"805d4345c6fb8f0ff03450d11502943227dc66c8","modified":1557671594000},{"_id":"source/img/article_header/tizi.jpg","hash":"4309e0c07f58d0378f0eea20cbe6b8e73885add8","modified":1555416123000},{"_id":"source/img/header_img/about.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1555309775000},{"_id":"source/img/header_img/earch.jpg","hash":"7baa2660db94e294dff0ff020a40362a347955fb","modified":1555416138000},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1555309775000},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1555309776000},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1555309776000},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1555309776000},{"_id":"source/img/article/upload-file.png","hash":"e08a699d53c2a88cf69023ef830136712a58dfb3","modified":1556077421000},{"_id":"source/img/article_header/bullon.jpg","hash":"441949032a38812af1f1ae25f815c04494fcf459","modified":1555402577000},{"_id":"source/img/header_img/archive.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1555309775000},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1555309775000},{"_id":"source/img/header_img/xirikui.jpg","hash":"0df1f82b24e2015fd4611cfc24a10647b1db164c","modified":1555416108000},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1555309775000},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1555309776000},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1555309775000},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1555309776000},{"_id":"source/img/article/github-pages.png","hash":"6d640742e3d0377bda56c1920b36f120e137362a","modified":1555385533000},{"_id":"source/img/article/report-meta-date.png","hash":"dd6fc218d0247a8753ad655b45caf8f5cef9a6d2","modified":1555994097000},{"_id":"source/img/header_img/pencil.jpg","hash":"5f8f4b11e0dbe4e685fbca95391005ab4b8ca423","modified":1555416151000},{"_id":"source/img/pay/wechat_pay.png","hash":"1503eb2c9206aac256787b1bed84f9c3452e0a4d","modified":1555309775000},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1555309775000},{"_id":"source/img/header_img/moutain.jpg","hash":"2233c072ae023771f84b46346b0bb0104693963f","modified":1555416176000},{"_id":"source/img/pay/ali_pay.png","hash":"15b04dda349b629e4c996a3390a2e620c4d5b269","modified":1555309775000},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1555309776000},{"_id":"source/img/article_header/article_bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1555309775000},{"_id":"source/img/header_img/road2.jpg","hash":"c9ff82ce7b69c2e410684bd2ba0f51d8a5c5790c","modified":1555416031000},{"_id":"source/img/header_img/road.jpg","hash":"941e6bcf770827b5bd392ce9bfabe77c93a5259c","modified":1555415993000},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1555309775000},{"_id":"source/img/article/domain.jpeg","hash":"07cdfcd896dfad648b5526af5f5b3b9eb3150665","modified":1555385533000},{"_id":"source/img/article/huweihuang_blog.png","hash":"392cf8b33be6c752dd908e027fa3346a6ecd58ab","modified":1555309775000},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1555309775000},{"_id":"source/img/header_img/tag.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1555309775000},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1555309775000},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1555309775000},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1555309775000},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1555309775000}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2020-01-14T05:50:32.768Z","updated":"2019-04-15T06:29:35.000Z","path":"404.html","title":"","comments":1,"_id":"ck5dutbi60000wf73rv17096d","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2019-04-15T06:29:35.000Z","path":"archive/index.html","_id":"ck5dutbj40002wf73935nzdi6","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2019-04-15T02:48:33.000Z","description":"不断改进软件测试方法","header-img":"/img/header_img/about.jpg","aplayer":false,"fixed":false,"_content":"\n### 一句话\n\n> 在实践中提高，在交流中进步。\n\n### 关于我\n\n>喜欢研究技术，也喜欢分享。\n>\n>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。\n>\n>希望写一些对大家有用的文字。\n\n### 兴趣方向\n\n> 引进新的技术，不断改进软件测试方法\n\n### 参与社区\n\n > CSDN博客：httsp://blog.csdn.et/liuchunming033\n >\n > Github：https://github.com/liuchunming033\n > \n > 2018全球架构师峰会：https://bj2018.archsummit.com/presentation/1330\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2019-04-15 10:48:33\ndescription: \"不断改进软件测试方法\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: false \nfixed: false\n---\n\n### 一句话\n\n> 在实践中提高，在交流中进步。\n\n### 关于我\n\n>喜欢研究技术，也喜欢分享。\n>\n>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。\n>\n>希望写一些对大家有用的文字。\n\n### 兴趣方向\n\n> 引进新的技术，不断改进软件测试方法\n\n### 参与社区\n\n > CSDN博客：httsp://blog.csdn.et/liuchunming033\n >\n > Github：https://github.com/liuchunming033\n > \n > 2018全球架构师峰会：https://bj2018.archsummit.com/presentation/1330\n\n### 联系我\n\n>Email: liuchunming033@163.com \n\n\n","updated":"2019-04-18T07:03:58.000Z","path":"about/index.html","comments":1,"_id":"ck5dutbj60004wf73qs5mxjff","content":"<h3 id=\"一句话\">一句话</h3>\n<blockquote>\n<p>在实践中提高，在交流中进步。</p>\n</blockquote>\n<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>喜欢研究技术，也喜欢分享。</p>\n<p>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。</p>\n<p>希望写一些对大家有用的文字。</p>\n</blockquote>\n<h3 id=\"兴趣方向\">兴趣方向</h3>\n<blockquote>\n<p>引进新的技术，不断改进软件测试方法</p>\n</blockquote>\n<h3 id=\"参与社区\">参与社区</h3>\n<blockquote>\n<p>CSDN博客：httsp://blog.csdn.et/liuchunming033</p>\n<p>Github：<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n<p>2018全球架构师峰会：<a href=\"https://bj2018.archsummit.com/presentation/1330\" target=\"_blank\" rel=\"noopener\">https://bj2018.archsummit.com/presentation/1330</a></p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3>一句话</h3>\n<blockquote>\n<p>在实践中提高，在交流中进步。</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>喜欢研究技术，也喜欢分享。</p>\n<p>在软件测试领域摸爬了快10年了，做过嵌入式、服务端、WEB端、APP端、性能以及测试框架和测试平台开发。</p>\n<p>希望写一些对大家有用的文字。</p>\n</blockquote>\n<h3>兴趣方向</h3>\n<blockquote>\n<p>引进新的技术，不断改进软件测试方法</p>\n</blockquote>\n<h3>参与社区</h3>\n<blockquote>\n<p>CSDN博客：httsp://blog.csdn.et/liuchunming033</p>\n<p>Github：<a href=\"https://github.com/liuchunming033\" target=\"_blank\" rel=\"noopener\">https://github.com/liuchunming033</a></p>\n<p>2018全球架构师峰会：<a href=\"https://bj2018.archsummit.com/presentation/1330\" target=\"_blank\" rel=\"noopener\">https://bj2018.archsummit.com/presentation/1330</a></p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:liuchunming033@163.com\" target=\"_blank\" rel=\"noopener\">liuchunming033@163.com</a></p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2019-05-24T14:52:38.138Z","updated":"2019-04-15T06:29:35.000Z","path":"tags/index.html","comments":1,"_id":"ck5dutbk2000fwf73uym8vg5x","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hexo博客入门","catalog":true,"toc_nav_num":true,"date":"2019-04-15T02:51:24.000Z","subtitle":"从0开始搭建Hexo博客","header-img":"/img/article_header/article_header.png","top":9,"catagories":["Hexo"],"_content":"\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","source":"_posts/Hexo博客入门.md","raw":"---\ntitle: \"Hexo博客入门\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-15 10:51:24\nsubtitle: \"从0开始搭建Hexo博客\"\nheader-img: \"/img/article_header/article_header.png\"\ntop: 9\ntags:\n- Hexo\ncatagories:\n- Hexo\n---\n\n> [Hexo](https://hexo.io/zh-cn/)是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：\n\n- 超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。\n\n- 支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。\n\n- 一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。\n\n- 丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。\n\n本篇文章带你一步一步搭建起可公网访问的博客系统。\n\n## 安装Hexo\n\n首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。\n\n```shell\n#For Mac\nbrew install node\nbrew install git\n```\n\n安装Hexo\n\n```shell\nnpm install hexo-cli -g\n```\n\n## 快速启动一个博客\n```shell\nhexo init blog\ncd blog\nnpm install\nhexo server\n```\n接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。\n\n## 创建一篇自己的博文\n```shell\nhexo new \"My New Post\"\n```\n\n这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：\n\n```markdown\n\n---\ntitle: My New Post\ndate: 2019-04-15 16:20:12\ntags:\n---\n```\n文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。\n\n## 让更多人看到你的博客\n前面我们`hexo server`可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。\n\n### 新建Github仓库\n在自己的Github主页右上角头像旁边,选择下拉菜单中的`New repository`，给新的仓库起名字必须按照这个格式：{github账号}.github.io。\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 liuchunming033.github.io\n\n### 设置部署选项\n将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：\n```yaml\ndeploy:\n  type: git\n  repository: https://github.com/liuchunming033/liuchunming033.github.io.git\n  branch: master\n```\n注意，把liuchunming033替换成你自己的github账户名。\n\n### 部署博客站点到Github\n在博客的根目录下，执行以下指令即可完成部署：\n```shell\nhexo clean && hexo generate\nhexo deploy\n```\n这时候，在浏览器中打开[http://liuchunming033.github.io]()网址，就可以看到你的博客站点了。是不是有点激动。\n注意：`hexo deloy`依赖`hexo-deployer-git`包，需要事先通过npm安装它：\n`npm install hexo-deployer-git --save`\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。\n\n### 配置HTTPS和自定义域名\n前面我们可以通过[https://liuchunming033.github.io]()访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将`Enforce HTTPS`勾上，这样你的博客就可以通过HTTPS访问了。\n可以参考我的博客配置：\n![](/img/article/github-pages.png)配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：\n![](/img/article/domain.jpeg)解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 liuchunming033.github.io。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：liuchunming.net。\n\n这样你就可以在浏览器上通过https://liuchunming.net访问博客了。\n\n## 个性化主题\n### 更换主题模板\nHexo博客提供丰富的主题模板，可以到[Hexo主题](https://hexo.io/themes/)页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。\n那么，进入到博客目录中执行下面的命令安装主题模板：\n```shell\ngit clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang\n```\n然后到博客配置文件`_config.yml`中修改主题：\n```yaml\ntheme: huweihuang\n```\n然后执行下面的命令查看一下你的博客：\n```shell\nhexo server\n```\n可以发现博客主题已经更换了。\n\n### 边栏设置\n更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。\n比如头像、个性签名、边栏要展示的插件，修改 `_config.yml`如下:\n```yml\n# Sidebar settings\nsidebar: true   # whether or not using Sidebar.\nsidebar-about-description: \"Stay hungry,Stay foolish\"\nsidebar-avatar: /img/avatar/ironman.png  # use absolute URL, seeing it's used in both `/` and `/about/`\nwidgets:\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n#- category\n```\n可以在模板的`layout/_widget`中新增新的插件。\n### 评论区设置\n博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统[Valine](https://valine.js.org/)。\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。\n修改主题的配置文件 `_config.yml`如下:\n```yaml\nvaline:\n  enable: true\n  app_id: {App ID}\n  app_key: {App Key}\n```\n接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：\n```JavaScript\n<% if(theme.valine.enable) { %>\n    <div class=\"vcomment\"></div>\n    <script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"></script>\n    <script src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>\n    <script>\n        new Valine({\n            el: '.vcomment',\n            visitor: true,\n            appId: '<%=theme.valine.app_id %>',\n            appKey: '<%=theme.valine.app_key %>',\n            placeholder: 'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦',\n            avatar: 'mm',\n            pageSize: 10,\n            meta: ['nick','mail'],\n            notify: true\n        })\n    </script>\n<% } %>\n```\n然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：\n```javascript\n<!--加载valine-->\n<%- partial('_partial/comments') %>\n<!--加载valine-->  \n```\n这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：\n```css\n.v .vinput {\n  font-size: 1.5rem !important;\n}\n\n.v .veditor {\n  font-size: 1.5rem !important;\n}\n\n.v .vbtn {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .col {\n  font-size: 1.5rem !important;\n}\n\n.v .vinfo .vcount .vnum {\n  font-size: 1.5rem !important;\n}\n\n.v .power {\n  display: none !important;\n}\n\n.v .vlist .vcard .vhead .vnick {\n  font-size: 1.5rem !important;\n}\n\n.v .vlist .vcard .vhead .vsys {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vtime {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vh .vat {\n  font-size: 1.2rem !important;\n}\n\n.v .vlist .vcard .vcontent {\n  font-size: 1.5rem !important;\n}\n```\n这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。\n\n### 相关文章设置\n相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：\n```javascript\n<% var post_list = recommended_posts(page, site) %>\n<% if(post_list.length > 0) { %>\n    <div class=\"recommended_posts\">\n        <h2><span style=\"font-size:1em\"><%- config['recommended_posts']['titleHtml'] %></span></h2>\n        <ul>\n            <% post_list.forEach(function(link) { %>\n                <li><a href=\"<%= link.permalink %>\"><%= link.title %></a></li>\n            <% }) %>\n        </ul>\n    </div>\n<% } %>\n```\n在博客的配置文件_config.yml中对相关文章数量、文案进行设置：\n```yaml\nrecommended_posts:\n  server: https://api.truelaurel.com #后端推荐服务器地址\n  timeoutInMillis: 10000 #服务时长，超过此时长，则使用离线推荐模式\n  internalLinks: 5 #内部文章数量\n  externalLinks: 0 #外部文章数量\n  autoDisplay: true, #自动在文章底部显示推荐文章\n  titleHtml: 相关文章 #自定义标题\n```\n最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：\n```javascript\n<!-- 相关文章 -->\n<% if(config['recommended_posts']) { %>\n<%- partial('_partial/recommend_posts', {page: page, site: site}) %>\n<% } %>\n```\n## 总结\n至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~","slug":"Hexo博客入门","published":1,"updated":"2019-04-16T03:32:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dutbj00001wf738yzi1kmd","content":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2 id=\"安装hexo\">安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速启动一个博客\">快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2 id=\"创建一篇自己的博文\">创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2 id=\"让更多人看到你的博客\">让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3 id=\"新建github仓库\">新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3 id=\"设置部署选项\">设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3 id=\"部署博客站点到github\">部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3 id=\"配置https和自定义域名\">配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2 id=\"个性化主题\">个性化主题</h2>\n<h3 id=\"更换主题模板\">更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3 id=\"边栏设置\">边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3 id=\"评论区设置\">评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3 id=\"相关文章设置\">相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">Hexo</a>是一款基于Node.js的快速、简洁且高效的博客框架。具有以下几个特点：</p>\n</blockquote>\n<ul>\n<li>\n<p>超快速度： Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</p>\n</li>\n<li>\n<p>支持 Markdown： Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</p>\n</li>\n<li>\n<p>一键部署： 只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。</p>\n</li>\n<li>\n<p>丰富的插件： Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</p>\n</li>\n</ul>\n<p>本篇文章带你一步一步搭建起可公网访问的博客系统。</p>\n<h2>安装Hexo</h2>\n<p>首先安装 Node.js 和 Git工具。因为Hexo博客依赖这两个基本的开发工具。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>For Mac</span><br><span class=\"line\">brew install node</span><br><span class=\"line\">brew install git</span><br></pre></td></tr></table></figure>\n<p>安装Hexo</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n<h2>快速启动一个博客</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog</span><br><span class=\"line\">cd blog</span><br><span class=\"line\">npm install</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>接着，在浏览器中浏览http://localhost:4000，就可以看到博客了，这个博客默认一篇Hello World的博文。<br>\n这篇博文来自博客目录里面source/_posts子目录下的hello-world.md。以后我们写博文也是在这个目录下编写markdown格式的文件。</p>\n<h2>创建一篇自己的博文</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new \"My New Post\"</span><br></pre></td></tr></table></figure>\n<p>这样将会在source/_posts/目录下创建一篇博文My-New-Post.md。打开这片文章，可以看到如下的内容：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">title: My New Post</span><br><span class=\"line\">date: 2019-04-15 16:20:12</span><br><span class=\"line\">tags:</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>文章中有文章的title，有文章创建的日期，有tags（作为文章的标签，可以用于分类）。</p>\n<h2>让更多人看到你的博客</h2>\n<p>前面我们<code>hexo server</code>可以本地调试我们的博客站点，当发现一切OK后，我们希望将博客的站点放到网上，让更多的人看到博客里的文章。<br>\n对于个人博客而言，非常推荐部署到Github上面，因为免费，够用。</p>\n<h3>新建Github仓库</h3>\n<p>在自己的Github主页右上角头像旁边,选择下拉菜单中的<code>New repository</code>，给新的仓库起名字必须按照这个格式：{github账号}.github.io。<br>\n比如我的Github账号是liuchunming033，则我创建的用于部署博客的仓库名字就必须叫做 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a></p>\n<h3>设置部署选项</h3>\n<p>将本地的文件部署（上传）到Github账户中，编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repository:</span> <span class=\"attr\">https://github.com/liuchunming033/liuchunming033.github.io.git</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">master</span></span><br></pre></td></tr></table></figure>\n<p>注意，把liuchunming033替换成你自己的github账户名。</p>\n<h3>部署博客站点到Github</h3>\n<p>在博客的根目录下，执行以下指令即可完成部署：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>这时候，在浏览器中打开<a href=\"\">http://liuchunming033.github.io</a>网址，就可以看到你的博客站点了。是不是有点激动。<br>\n注意：<code>hexo deloy</code>依赖<code>hexo-deployer-git</code>包，需要事先通过npm安装它：<br>\n<code>npm install hexo-deployer-git --save</code><br>\n以后我们新建博文准备发布的时候，只需要执行上面的命令就可以了。</p>\n<h3>配置HTTPS和自定义域名</h3>\n<p>前面我们可以通过<a href=\"\">https://liuchunming033.github.io</a>访问我们的博客站点了。如果你有自己的域名（没有的话可以去申请一个，不贵），一定会想将博客站点解析到你的域名上。下面我们就来操作。<br>\n在Github上打开存放博客的repository，在settings页面的GitHub Pages部分，填写上你的域名即可。强烈建议将<code>Enforce HTTPS</code>勾上，这样你的博客就可以通过HTTPS访问了。<br>\n可以参考我的博客配置：<br>\n<img src=\"/img/article/github-pages.png\" alt=\"\">配置好repository之后，要到你的域名运营商那里，进行CNAME解析，将你的域名解析到 liuchunming033.github.io上，比如我的域名是在阿里云上注册的，在阿里云域名控制台上解析域名的方式如下图：<br>\n<img src=\"/img/article/domain.jpeg\" alt=\"\">解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是 <a href=\"http://liuchunming033.github.io\" target=\"_blank\" rel=\"noopener\">liuchunming033.github.io</a>。接着你需要做的是在博客的根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：<a href=\"http://liuchunming.net\" target=\"_blank\" rel=\"noopener\">liuchunming.net</a>。</p>\n<p>这样你就可以在浏览器上通过https://liuchunming.net访问博客了。</p>\n<h2>个性化主题</h2>\n<h3>更换主题模板</h3>\n<p>Hexo博客提供丰富的主题模板，可以到<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">Hexo主题</a>页面挑选你喜欢的主题，比如我比较喜欢这个模板hexo-theme-huweihuang。<br>\n那么，进入到博客目录中执行下面的命令安装主题模板：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/huweihuang/hexo-theme-huweihuang.git .themes/huweihuang</span><br></pre></td></tr></table></figure>\n<p>然后到博客配置文件<code>_config.yml</code>中修改主题：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">huweihuang</span></span><br></pre></td></tr></table></figure>\n<p>然后执行下面的命令查看一下你的博客：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>可以发现博客主题已经更换了。</p>\n<h3>边栏设置</h3>\n<p>更换完主题后，发现末模板的很多配置还是模板的作者的。我们需要按照自己的配置进行修改。我们先修改下huweihuang主题的右边栏部分。<br>\n比如头像、个性签名、边栏要展示的插件，修改 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Sidebar settings</span></span><br><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"Stay hungry,Stay foolish\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">/img/avatar/ironman.png</span>  <span class=\"comment\"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class=\"line\"><span class=\"attr\">widgets:</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"comment\">#- category</span></span><br></pre></td></tr></table></figure>\n<p>可以在模板的<code>layout/_widget</code>中新增新的插件。</p>\n<h3>评论区设置</h3>\n<p>博客添加评论功能，方便读者与作者交流。我的博客选择了一个比较简约的评论系统<a href=\"https://valine.js.org/\" target=\"_blank\" rel=\"noopener\">Valine</a>。<br>\n想要使用Valine，必须注册LeanCloud并创建一个开发版应用（免费），注册完应用之后，就可以拿到App ID和App Key了，这两个重要的数据在下面的配置需要用到。<br>\n修改主题的配置文件 <code>_config.yml</code>如下:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">valine:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  app_id:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">ID&#125;</span></span><br><span class=\"line\"><span class=\"attr\">  app_key:</span> <span class=\"string\">&#123;App</span> <span class=\"string\">Key&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，在主题的layout/_partial/新建comments.ejs文件，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(theme.valine.enable) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"vcomment\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script src=<span class=\"string\">'//unpkg.com/valine@latest/dist/Valine.min.js'</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Valine(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'.vcomment'</span>,</span><br><span class=\"line\">            visitor: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            appId: <span class=\"string\">'&lt;%=theme.valine.app_id %&gt;'</span>,</span><br><span class=\"line\">            appKey: <span class=\"string\">'&lt;%=theme.valine.app_key %&gt;'</span>,</span><br><span class=\"line\">            placeholder: <span class=\"string\">'ヾﾉ≧∀≦)o发表你的高见吧, 可以留下邮箱接收评论回复的提醒哦'</span>,</span><br><span class=\"line\">            avatar: <span class=\"string\">'mm'</span>,</span><br><span class=\"line\">            pageSize: <span class=\"number\">10</span>,</span><br><span class=\"line\">            meta: [<span class=\"string\">'nick'</span>,<span class=\"string\">'mail'</span>],</span><br><span class=\"line\">            notify: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>\n<p>然后在需要添加评论框的页面对应的位置引用comments.ejs，比如我会在博文的底部引入评论框，所以我在主题的post.ejs中加入下面的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--加载valine--&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/comments'</span>) %&gt;</span><br><span class=\"line\">&lt;!--加载valine--&gt;</span><br></pre></td></tr></table></figure>\n<p>这样，在每篇博文的底部就都有评论框了。但是我们发现评论框区域的字体实在是太小了，我们自定义CSS修改一下，在主题的source/css/中新加valine.css文件，内容如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinput</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.veditor</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vbtn</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.col</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vinfo</span> <span class=\"selector-class\">.vcount</span> <span class=\"selector-class\">.vnum</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.power</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vnick</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vhead</span> <span class=\"selector-class\">.vsys</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vtime</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vh</span> <span class=\"selector-class\">.vat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.v</span> <span class=\"selector-class\">.vlist</span> <span class=\"selector-class\">.vcard</span> <span class=\"selector-class\">.vcontent</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.5rem</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样看起来舒服多了。所有的评论内容都会在Leancloud的存储中看到。</p>\n<h3>相关文章设置</h3>\n<p>相关文章功能在博文底部展示与博文相关的文章，是个非常不错的主意，根据tag与博文匹配的多少来自动索引博客站点中的博文作为相关文章。<br>\n在主题的layout/_partial中新建recommend_posts.ejs，内容如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% <span class=\"keyword\">var</span> post_list = recommended_posts(page, site) %&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(post_list.length &gt; <span class=\"number\">0</span>) &#123; %&gt;</span><br><span class=\"line\">    &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"recommended_posts\"</span>&gt;</span><br><span class=\"line\">        &lt;h2&gt;&lt;span style=\"font-size:1em\"&gt;&lt;%- config['recommended_posts']['titleHtml'] %&gt;&lt;/span&gt;&lt;/h2&gt;</span><br><span class=\"line\">        &lt;ul&gt;</span><br><span class=\"line\">            &lt;% post_list.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">link</span>) </span>&#123; %&gt;</span><br><span class=\"line\">                &lt;li&gt;&lt;a href=\"&lt;%= link.permalink %&gt;\"&gt;&lt;%= link.title %&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">            &lt;% &#125;) %&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/ul&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<p>在博客的配置文件_config.yml中对相关文章数量、文案进行设置：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">recommended_posts:</span></span><br><span class=\"line\"><span class=\"attr\">  server:</span> <span class=\"attr\">https://api.truelaurel.com</span> <span class=\"comment\">#后端推荐服务器地址</span></span><br><span class=\"line\"><span class=\"attr\">  timeoutInMillis:</span> <span class=\"number\">10000</span> <span class=\"comment\">#服务时长，超过此时长，则使用离线推荐模式</span></span><br><span class=\"line\"><span class=\"attr\">  internalLinks:</span> <span class=\"number\">5</span> <span class=\"comment\">#内部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  externalLinks:</span> <span class=\"number\">0</span> <span class=\"comment\">#外部文章数量</span></span><br><span class=\"line\"><span class=\"attr\">  autoDisplay:</span> <span class=\"literal\">true</span><span class=\"string\">,</span> <span class=\"comment\">#自动在文章底部显示推荐文章</span></span><br><span class=\"line\"><span class=\"attr\">  titleHtml:</span> <span class=\"string\">相关文章</span> <span class=\"comment\">#自定义标题</span></span><br></pre></td></tr></table></figure>\n<p>最后，在博文的模板文件中引用它，在主题中的layout/post.ejs中添加下面的部分：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 相关文章 --&gt;</span><br><span class=\"line\">&lt;% <span class=\"keyword\">if</span>(config[<span class=\"string\">'recommended_posts'</span>]) &#123; %&gt;</span><br><span class=\"line\">&lt;%- partial(<span class=\"string\">'_partial/recommend_posts'</span>, &#123;<span class=\"attr\">page</span>: page, <span class=\"attr\">site</span>: site&#125;) %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>至此，我们的博客已经配置了侧边栏、评论区、相关文章区，并且已经可以公网访问了。下面就开始写博客内容吧~</p>\n"},{"title":"深入理解Docker容器和镜像的核心原理","catalog":true,"toc_nav_num":true,"date":"2019-05-12T12:51:24.000Z","subtitle":"从Namespace、CGroups和Mount介绍容器和镜像的技术原理","header-img":"/img/article_header/tizi.jpg","catagories":["Docker"],"_content":"> 本篇文章介绍容器的本质是一种特殊进程，Docker利用Namespace实现容器中进程的隔离，并且利用CGroups机制实现容器对宿主机资源的访问限制。\n\n上一篇文章[\"通过容器化Python Web应用了解Docker容器的核心功能\"](https://liuchunming.net/article/%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%8C%96Python%20web%E5%BA%94%E7%94%A8%E4%BA%86%E8%A7%A3Docker%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/)中，我们了解了如何通过镜像启动容器以及对容器的各种操作方法。这篇文章，我们来深入学习容器背后的技术原理。\n\n## 容器是一种特殊进程\n从容器的使用上，我们可以这样理解：容器其实是一种沙盒技术。也就是说容器像一个集装箱一样，把你的应用“装”起来。这样，应用与应用之间，就因为有了**边界**而不至于相互干扰。下面，我们就了解一下这个“边界”是如何实现的。\n\n在了解\"边界\"是如何实现之前，我们来看看到底这个\"边界\"是什么。首先来运行一个容器来试试：\n```text\ndocker run -d -p 5000:80 helloworld /bin/sh\n```\n-it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。\n\n这样，执行`docker run`命令的机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。\n\n执行上面的命令后，我们就进入到了由镜像helloworld启动的容器中，在容器中我们执行ps命令：\n```text\n# ps -a\nPID   USER     TIME  COMMAND\n    1 root      0:15 python app.py\n   17 root      0:00 /bin/sh\n   29 root      0:00 ps -a\n```\n可以看到，python app.py，是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有3个进程在运行。我们知道在一台Linux机器上，只能有一个PID=1的进程，也就是init进程。而容器中又出现了一个PID=1的进程，这也就意味着容器中的三个进程被 Docker 隔离在了一个跟宿主机完全不同的世界当中。\n\n这究竟是怎么做到呢？\n\n本来，每当我们在宿主机上运行 python app.py 程序，操作系统都会给它分配一个进程编号，比如 PID=100。而现在，我们要通过 Docker 把这个 python app.py 程序运行在一个容器当中，他的PID就变成了1。\n\n这其实是对应用的进程空间做了手脚，使得 python app.py 进程被隔离起来，在这个隔离的空间中，进程编号PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。\n\n实现这种隔离的技术，就是 Linux 里面的 Namespace 机制。 Namespace其实只是 Linux 创建新进程的一个可选参数。\n\n在Linux系统中，创建新进程需要调用系统调用clone()，当我们用 clone() 创建一个新进程时，可以在参数中指定 CLONE_NEWPID 参数，这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。\n\n当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。\n\n除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。\n\n比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。\n\nDocker在帮助用户启动容器中的进程时，指定了这个进程所需要启用的各种 Namespace 参数。这样，在容器中就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。\n\n所以说，容器，其实是一种特殊的进程。\n\n容器化后的用户应用，依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要想虚拟化软件那样单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。所以说，“高性能”是容器相较于虚拟机最大的优势。\n\n既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核的。虽然Docker利用了Namespace实现了进程的隔离，但是在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。\n\n## 限制容器的资源使用\n为什么还需要对容器做“限制”呢？\n\n容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。\n\nLinux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups 的全称是 Linux Control Group，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正式利用了这一机制实现对容器进程的资源限制。\n\n在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在CentOS下，可以用 mount 指令把它们展示出来\n```text\nmount -t cgroup\ncgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)\ncgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)\ncgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)\ncgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)\ncgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)\ncgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)\ncgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)\ncgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)\ncgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)\ncgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)\ncgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)\n```\n它的输出结果，是一系列文件系统目录。如果你在自己的机器上没有看到这些目录，那你就需要自己去挂载 Cgroups。\n\n在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些是当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。\n\n比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是`ls /sys/fs/cgroup/cpu`：\n```text\nls /sys/fs/cgroup/cpu\ncgroup.clone_children  cgroup.procs          cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  cpuacct.stat   cpuacct.usage_percpu  release_agent\ncgroup.event_control   cgroup.sane_behavior  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    cpuacct.usage  notify_on_release     tasks\n```\n在它的输出里注意到有 cfs_period 和 cfs_quota这两个参数，它们需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。\n\n## 镜像是怎么组成的\n\n## 总结\n本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。\n","source":"_posts/深入理解Docker容器和镜像的核心原理.md","raw":"---\ntitle: \"深入理解Docker容器和镜像的核心原理\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-05-12 20:51:24\nsubtitle: \"从Namespace、CGroups和Mount介绍容器和镜像的技术原理\"\nheader-img: \"/img/article_header/tizi.jpg\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n> 本篇文章介绍容器的本质是一种特殊进程，Docker利用Namespace实现容器中进程的隔离，并且利用CGroups机制实现容器对宿主机资源的访问限制。\n\n上一篇文章[\"通过容器化Python Web应用了解Docker容器的核心功能\"](https://liuchunming.net/article/%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%8C%96Python%20web%E5%BA%94%E7%94%A8%E4%BA%86%E8%A7%A3Docker%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/)中，我们了解了如何通过镜像启动容器以及对容器的各种操作方法。这篇文章，我们来深入学习容器背后的技术原理。\n\n## 容器是一种特殊进程\n从容器的使用上，我们可以这样理解：容器其实是一种沙盒技术。也就是说容器像一个集装箱一样，把你的应用“装”起来。这样，应用与应用之间，就因为有了**边界**而不至于相互干扰。下面，我们就了解一下这个“边界”是如何实现的。\n\n在了解\"边界\"是如何实现之前，我们来看看到底这个\"边界\"是什么。首先来运行一个容器来试试：\n```text\ndocker run -d -p 5000:80 helloworld /bin/sh\n```\n-it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。\n\n这样，执行`docker run`命令的机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。\n\n执行上面的命令后，我们就进入到了由镜像helloworld启动的容器中，在容器中我们执行ps命令：\n```text\n# ps -a\nPID   USER     TIME  COMMAND\n    1 root      0:15 python app.py\n   17 root      0:00 /bin/sh\n   29 root      0:00 ps -a\n```\n可以看到，python app.py，是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有3个进程在运行。我们知道在一台Linux机器上，只能有一个PID=1的进程，也就是init进程。而容器中又出现了一个PID=1的进程，这也就意味着容器中的三个进程被 Docker 隔离在了一个跟宿主机完全不同的世界当中。\n\n这究竟是怎么做到呢？\n\n本来，每当我们在宿主机上运行 python app.py 程序，操作系统都会给它分配一个进程编号，比如 PID=100。而现在，我们要通过 Docker 把这个 python app.py 程序运行在一个容器当中，他的PID就变成了1。\n\n这其实是对应用的进程空间做了手脚，使得 python app.py 进程被隔离起来，在这个隔离的空间中，进程编号PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。\n\n实现这种隔离的技术，就是 Linux 里面的 Namespace 机制。 Namespace其实只是 Linux 创建新进程的一个可选参数。\n\n在Linux系统中，创建新进程需要调用系统调用clone()，当我们用 clone() 创建一个新进程时，可以在参数中指定 CLONE_NEWPID 参数，这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。\n\n当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。\n\n除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。\n\n比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。\n\nDocker在帮助用户启动容器中的进程时，指定了这个进程所需要启用的各种 Namespace 参数。这样，在容器中就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。\n\n所以说，容器，其实是一种特殊的进程。\n\n容器化后的用户应用，依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要想虚拟化软件那样单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。所以说，“高性能”是容器相较于虚拟机最大的优势。\n\n既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核的。虽然Docker利用了Namespace实现了进程的隔离，但是在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。\n\n## 限制容器的资源使用\n为什么还需要对容器做“限制”呢？\n\n容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。\n\nLinux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups 的全称是 Linux Control Group，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正式利用了这一机制实现对容器进程的资源限制。\n\n在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在CentOS下，可以用 mount 指令把它们展示出来\n```text\nmount -t cgroup\ncgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)\ncgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)\ncgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)\ncgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)\ncgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)\ncgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)\ncgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)\ncgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)\ncgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)\ncgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)\ncgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)\n```\n它的输出结果，是一系列文件系统目录。如果你在自己的机器上没有看到这些目录，那你就需要自己去挂载 Cgroups。\n\n在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些是当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。\n\n比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是`ls /sys/fs/cgroup/cpu`：\n```text\nls /sys/fs/cgroup/cpu\ncgroup.clone_children  cgroup.procs          cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  cpuacct.stat   cpuacct.usage_percpu  release_agent\ncgroup.event_control   cgroup.sane_behavior  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    cpuacct.usage  notify_on_release     tasks\n```\n在它的输出里注意到有 cfs_period 和 cfs_quota这两个参数，它们需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。\n\n## 镜像是怎么组成的\n\n## 总结\n本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。\n","slug":"深入理解Docker容器和镜像的核心原理","published":1,"updated":"2019-05-14T02:16:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dutbj50003wf73kon5dq03","content":"<blockquote>\n<p>本篇文章介绍容器的本质是一种特殊进程，Docker利用Namespace实现容器中进程的隔离，并且利用CGroups机制实现容器对宿主机资源的访问限制。</p>\n</blockquote>\n<p>上一篇文章<a href=\"https://liuchunming.net/article/%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%8C%96Python%20web%E5%BA%94%E7%94%A8%E4%BA%86%E8%A7%A3Docker%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/\" target=\"_blank\" rel=\"noopener\">&quot;通过容器化Python Web应用了解Docker容器的核心功能&quot;</a>中，我们了解了如何通过镜像启动容器以及对容器的各种操作方法。这篇文章，我们来深入学习容器背后的技术原理。</p>\n<h2 id=\"容器是一种特殊进程\">容器是一种特殊进程</h2>\n<p>从容器的使用上，我们可以这样理解：容器其实是一种沙盒技术。也就是说容器像一个集装箱一样，把你的应用“装”起来。这样，应用与应用之间，就因为有了<strong>边界</strong>而不至于相互干扰。下面，我们就了解一下这个“边界”是如何实现的。</p>\n<p>在了解&quot;边界&quot;是如何实现之前，我们来看看到底这个&quot;边界&quot;是什么。首先来运行一个容器来试试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 5000:80 helloworld /bin/sh</span><br></pre></td></tr></table></figure>\n<p>-it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。</p>\n<p>这样，执行<code>docker run</code>命令的机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。</p>\n<p>执行上面的命令后，我们就进入到了由镜像helloworld启动的容器中，在容器中我们执行ps命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ps -a</span><br><span class=\"line\">PID   USER     TIME  COMMAND</span><br><span class=\"line\">    1 root      0:15 python app.py</span><br><span class=\"line\">   17 root      0:00 /bin/sh</span><br><span class=\"line\">   29 root      0:00 ps -a</span><br></pre></td></tr></table></figure>\n<p>可以看到，python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>，是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有3个进程在运行。我们知道在一台Linux机器上，只能有一个PID=1的进程，也就是init进程。而容器中又出现了一个PID=1的进程，这也就意味着容器中的三个进程被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>\n<p>这究竟是怎么做到呢？</p>\n<p>本来，每当我们在宿主机上运行 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 程序，操作系统都会给它分配一个进程编号，比如 PID=100。而现在，我们要通过 Docker 把这个 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 程序运行在一个容器当中，他的PID就变成了1。</p>\n<p>这其实是对应用的进程空间做了手脚，使得 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 进程被隔离起来，在这个隔离的空间中，进程编号PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</p>\n<p>实现这种隔离的技术，就是 Linux 里面的 Namespace 机制。 Namespace其实只是 Linux 创建新进程的一个可选参数。</p>\n<p>在Linux系统中，创建新进程需要调用系统调用clone()，当我们用 clone() 创建一个新进程时，可以在参数中指定 CLONE_NEWPID 参数，这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>\n<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>\n<p>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p>\n<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>\n<p>Docker在帮助用户启动容器中的进程时，指定了这个进程所需要启用的各种 Namespace 参数。这样，在容器中就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>\n<p>所以说，容器，其实是一种特殊的进程。</p>\n<p>容器化后的用户应用，依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要想虚拟化软件那样单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。所以说，“高性能”是容器相较于虚拟机最大的优势。</p>\n<p>既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核的。虽然Docker利用了Namespace实现了进程的隔离，但是在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。</p>\n<h2 id=\"限制容器的资源使用\">限制容器的资源使用</h2>\n<p>为什么还需要对容器做“限制”呢？</p>\n<p>容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。</p>\n<p>Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups 的全称是 Linux Control Group，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正式利用了这一机制实现对容器进程的资源限制。</p>\n<p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在CentOS下，可以用 mount 指令把它们展示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t cgroup</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure>\n<p>它的输出结果，是一系列文件系统目录。如果你在自己的机器上没有看到这些目录，那你就需要自己去挂载 Cgroups。</p>\n<p>在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些是当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。</p>\n<p>比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是<code>ls /sys/fs/cgroup/cpu</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /sys/fs/cgroup/cpu</span><br><span class=\"line\">cgroup.clone_children  cgroup.procs          cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  cpuacct.stat   cpuacct.usage_percpu  release_agent</span><br><span class=\"line\">cgroup.event_control   cgroup.sane_behavior  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    cpuacct.usage  notify_on_release     tasks</span><br></pre></td></tr></table></figure>\n<p>在它的输出里注意到有 cfs_period 和 cfs_quota这两个参数，它们需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p>\n<h2 id=\"镜像是怎么组成的\">镜像是怎么组成的</h2>\n<h2 id=\"总结\">总结</h2>\n<p>本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇文章介绍容器的本质是一种特殊进程，Docker利用Namespace实现容器中进程的隔离，并且利用CGroups机制实现容器对宿主机资源的访问限制。</p>\n</blockquote>\n<p>上一篇文章<a href=\"https://liuchunming.net/article/%E9%80%9A%E8%BF%87%E5%AE%B9%E5%99%A8%E5%8C%96Python%20web%E5%BA%94%E7%94%A8%E4%BA%86%E8%A7%A3Docker%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/\" target=\"_blank\" rel=\"noopener\">&quot;通过容器化Python Web应用了解Docker容器的核心功能&quot;</a>中，我们了解了如何通过镜像启动容器以及对容器的各种操作方法。这篇文章，我们来深入学习容器背后的技术原理。</p>\n<h2>容器是一种特殊进程</h2>\n<p>从容器的使用上，我们可以这样理解：容器其实是一种沙盒技术。也就是说容器像一个集装箱一样，把你的应用“装”起来。这样，应用与应用之间，就因为有了<strong>边界</strong>而不至于相互干扰。下面，我们就了解一下这个“边界”是如何实现的。</p>\n<p>在了解&quot;边界&quot;是如何实现之前，我们来看看到底这个&quot;边界&quot;是什么。首先来运行一个容器来试试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 5000:80 helloworld /bin/sh</span><br></pre></td></tr></table></figure>\n<p>-it 参数告诉了 Docker 项目在启动容器后，需要给我们分配一个文本输入 / 输出环境，也就是 TTY，跟容器的标准输入相关联，这样我们就可以和这个 Docker 容器进行交互了。而 /bin/sh 就是我们要在 Docker 容器里运行的程序。</p>\n<p>这样，执行<code>docker run</code>命令的机器就变成了一个宿主机，而一个运行着 /bin/sh 的容器，就跑在了这个宿主机里面。</p>\n<p>执行上面的命令后，我们就进入到了由镜像helloworld启动的容器中，在容器中我们执行ps命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ps -a</span><br><span class=\"line\">PID   USER     TIME  COMMAND</span><br><span class=\"line\">    1 root      0:15 python app.py</span><br><span class=\"line\">   17 root      0:00 /bin/sh</span><br><span class=\"line\">   29 root      0:00 ps -a</span><br></pre></td></tr></table></figure>\n<p>可以看到，python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>，是这个容器内部的第 1 号进程（PID=1），而这个容器里一共只有3个进程在运行。我们知道在一台Linux机器上，只能有一个PID=1的进程，也就是init进程。而容器中又出现了一个PID=1的进程，这也就意味着容器中的三个进程被 Docker 隔离在了一个跟宿主机完全不同的世界当中。</p>\n<p>这究竟是怎么做到呢？</p>\n<p>本来，每当我们在宿主机上运行 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 程序，操作系统都会给它分配一个进程编号，比如 PID=100。而现在，我们要通过 Docker 把这个 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 程序运行在一个容器当中，他的PID就变成了1。</p>\n<p>这其实是对应用的进程空间做了手脚，使得 python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 进程被隔离起来，在这个隔离的空间中，进程编号PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。</p>\n<p>实现这种隔离的技术，就是 Linux 里面的 Namespace 机制。 Namespace其实只是 Linux 创建新进程的一个可选参数。</p>\n<p>在Linux系统中，创建新进程需要调用系统调用clone()，当我们用 clone() 创建一个新进程时，可以在参数中指定 CLONE_NEWPID 参数，这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p>\n<p>当然，我们还可以多次执行上面的 clone() 调用，这样就会创建多个 PID Namespace，而每个 Namespace 里的应用进程，都会认为自己是当前容器里的第 1 号进程，它们既看不到宿主机里真正的进程空间，也看不到其他 PID Namespace 里的具体情况。</p>\n<p>除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。</p>\n<p>比如，Mount Namespace，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；Network Namespace，用于让被隔离进程看到当前 Namespace 里的网络设备和配置。</p>\n<p>Docker在帮助用户启动容器中的进程时，指定了这个进程所需要启用的各种 Namespace 参数。这样，在容器中就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。</p>\n<p>所以说，容器，其实是一种特殊的进程。</p>\n<p>容器化后的用户应用，依然还是一个宿主机上的普通进程，这就意味着这些因为虚拟化而带来的性能损耗都是不存在的；而另一方面，使用 Namespace 作为隔离手段的容器并不需要想虚拟化软件那样单独的 Guest OS，这就使得容器额外的资源占用几乎可以忽略不计。所以说，“高性能”是容器相较于虚拟机最大的优势。</p>\n<p>既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核的。虽然Docker利用了Namespace实现了进程的隔离，但是在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改。</p>\n<h2>限制容器的资源使用</h2>\n<p>为什么还需要对容器做“限制”呢？</p>\n<p>容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。</p>\n<p>Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。Linux Cgroups 的全称是 Linux Control Group，它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正式利用了这一机制实现对容器进程的资源限制。</p>\n<p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。在CentOS下，可以用 mount 指令把它们展示出来</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mount -t cgroup</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class=\"line\">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br></pre></td></tr></table></figure>\n<p>它的输出结果，是一系列文件系统目录。如果你在自己的机器上没有看到这些目录，那你就需要自己去挂载 Cgroups。</p>\n<p>在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录，也叫子系统。这些是当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。</p>\n<p>比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是<code>ls /sys/fs/cgroup/cpu</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /sys/fs/cgroup/cpu</span><br><span class=\"line\">cgroup.clone_children  cgroup.procs          cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  cpuacct.stat   cpuacct.usage_percpu  release_agent</span><br><span class=\"line\">cgroup.event_control   cgroup.sane_behavior  cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    cpuacct.usage  notify_on_release     tasks</span><br></pre></td></tr></table></figure>\n<p>在它的输出里注意到有 cfs_period 和 cfs_quota这两个参数，它们需要组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p>\n<h2>镜像是怎么组成的</h2>\n<h2>总结</h2>\n<p>本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。</p>\n"},{"title":"谈一谈软件测试中的测试数据准备","catalog":true,"toc_nav_num":true,"date":"2019-04-16T11:51:24.000Z","subtitle":"测试数据准备方法以及未来的发展方向","header-img":"/img/article_header/bullon.jpg","catagories":["软件测试"],"_content":"\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据平台\"从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。\n\n### 提供真实数据\n下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。\n\n比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。\n\n首先，使用pipenv创建虚拟环境，安装好Flask框架。\n```shell\nmkdir flasky\ncd flasky\npipenv --python 3.6\npipenv install flask\n```\n下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。\n```python\nimport time\nimport uuid\nimport requests\nfrom flasgger import swag_from\nfrom flask import Flask, jsonify,request\n\napp = Flask(__name__)\n\n@app.route('/api/1/vid', methods=['POST'])\n@swag_from('./register_vehicle.yml')\ndef register_vehicle():\n    args = request.args.to_dict()\n    if 'vin' not in args:\n        return jsonify(result_code=\"failed\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       debug_msg=\"vin is required\",\n                       data={})\n    payload = {\n        \"vin\": args.get(\"vin\", \"chunming12345678997\"),\n        \"color\": args.get(\"color\", \"blue\"),\n        \"plate_number\": args.get(\"plate_number\", \"京D12345\"),\n        \"model\": args.get(\"model\", \"ES8\"),\n        \"misc\": args.get(\"misc\", \"demo\")\n    }\n\n    r = requests.request(\"POST\", \"https://example.com/api/1/in/vehicle/profile\", data=payload)\n    response = jsonify(result_code=\"success\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       data=r.json())\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。\n\n### 提供Mock数据\n什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。\n\n其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：\n```python\nfrom flask import jsonify, Flask\nfrom flasgger import swag_from\nimport time\nimport uuid\napp = Flask(__name__)\n\nack = {\n    \"data\": {\n        \"ack\": 1\n    },\n    \"request_id\":str(uuid.uuid1()),\n    \"server_time\":int(time.time()),\n    \"result_code\":\"success\"\n}\n\n@app.route(\"/ack\", methods=['GET'])\n@swag_from('./register_vehicle.yml')\ndef get_ack():\n    return jsonify(ack)\n```\n通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。","source":"_posts/谈一谈软件测试中的测试数据准备.md","raw":"---\ntitle: \"谈一谈软件测试中的测试数据准备\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-04-16 19:51:24\nsubtitle: \"测试数据准备方法以及未来的发展方向\"\nheader-img: \"/img/article_header/bullon.jpg\"\ntags:\n- 软件测试\ncatagories:\n- 软件测试\n---\n\n> 测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。\n\n## 常见的测试数据准备方法\n我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：\n - 基于GUI的测试数据生成方法\n - 基于API的测试数据生成方法\n - 基于DB的测试数据生成方法\n - 基于MQ的测试数据生成方法\n - 基于第三方库方式的测试数据生成方法\n - 综合运用上述方法生成测试数据\n\n接下来，我们一起详细分析一下各种方法的有权点以及适用场景。\n\n### 基于GUI准备测试数据\n基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。\n\n比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。\n\n这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。\n\n但是，这种方法的缺点也非常明显，主要体现在以下几个方面：\n\n - **创建测试数据的效率低，不适合批量生成测试数据。** 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。\n - **基于GUI的测试数据生成方法不适合为自动化测试提供数据。** 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。\n - **会引入不必要的测试依赖。** 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。\n\n在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。\n\n基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。\n\n### 基于API准备测试数据\n通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。\n\n那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。\n\n 1. **API接口文档。** 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。\n 2. **通过抓包。**  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。\n 3. **查看日志文件。** 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。\n 4. **阅读源码。** 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。\n\n通过API构造测试数据的方法也不是完美的，主要有几个方面：\n\n 1. **不是所有的数据创建都有对应的API。**  \n 2. **有时候需要顺序调用多个API。** 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。\n\n调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。\n\n这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。\n\n### 基于DB准备测试数据\n通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。\n\n以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。\n\n这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。\n\n这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：\n\n 1. **有的测试数据准备涉及到的数据表太多。** 导致封装和维护测试准备函数的成本比较高。\n 2. **容易出现数据不完整和不一致。** 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。\n\n基于DB准备测试数据的方法，通常作为API方法的补充。\n \n### 基于MQ准备测试数据\n在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。\n\n比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。\n\n这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。\n\n### 基于第三方库准备测试数据\n我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（[项目地址](https://github.com/joke2k/faker)）这样的第三方库来实现：\n```\nfrom faker import Factory\n\nfake = Factory().create('zh_CN')\n\ndef random_phone_number():\n    '''随机手机号'''\n    return fake.phone_number()\n\ndef random_name():\n    \"\"\"随机姓名\"\"\"\n    return fake.name()\n\ndef random_address():\n    \"\"\"随机地址\"\"\"\n    return fake.address()\n\ndef random_email():\n    \"\"\"随机email\"\"\"\n    return fake.email()\n```\n这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。\n\n### 综合运用上述方法准备测试数据\n在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。\n\n我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。\n\n比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。\n\n为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。\n\n## 准备测试数据的时机\n前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。\n\n其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：\n\n 1. **创建测试数据所需要的时间。**  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。\n 2. **测试数据是否需要经常变动。** 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。\n 3. **测试数据是否存在于很多系统。**  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。\n 4. **构造测试数据的服务是否稳定。** 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。\n\n接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。\n\n### 实时创建（On-the-Fly）\n实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。\n\nOn-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。\n\n在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：\n**首先，有的测试数据比较耗时。** 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。\n**其次，测试数据本身之间复杂的关联性导致构造困难。** 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。\n\n比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。\n\n**微服务架构的流行导致成功生成测试数据的稳定性降低**  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。\n\n为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。\n\n### 提前准备（Out-of-Box）\nOut-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。\n\n那么Out-of-Box方法是否也存在缺点呢？\n\n最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。\n\n由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。\n\n为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。\n\n另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。\n\n实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。\n\n综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。\n\n## 构造测试数据的痛点及应对\n前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？\n\n### 调用封装函数的复杂性\n前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。\n\n比如，调用这样一个封装了注册车辆vid的函数：\n```\ndef  register_vehicle(vin, color, plate_number, model, misc):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\ncolor=\"blue\"\nplate_number=\"D12345\"\nmodel=\"PAD8\"\nmisc=\"demo\"\nvid = register_vehicle(vin, color, plate_number, model, misc)\n```\n由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：\n```\ndef  register_vehicle(vin=\"chunming\", color=\"blue\", plate_number=\"D12345\", model, misc=\"demo\"):\n    # 封装的处理过程\n\tretrun vid\n\t\nvin=\"chunming12345678997\"\nvid = register_vehicle(vin=vin)\n```\n这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。\n\n### 封装函数的版本管理\n通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。\n\n现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。\n\n为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。\n\n## 统一测试数据生成平台\n前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。\n\n现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用[Flask](http://flask.pocoo.org/)或者[Django REST framework](https://www.django-rest-framework.org/)包装成Restful API。\n\n这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。\n\n目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：\n![](/img/article/test-data-platform.png)<center>统一测试数据平台Restful API UI 界面</center>\n\n\"统一测试数据平台\"从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。\n\n### 提供真实数据\n下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。\n\n比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。\n\n首先，使用pipenv创建虚拟环境，安装好Flask框架。\n```shell\nmkdir flasky\ncd flasky\npipenv --python 3.6\npipenv install flask\n```\n下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。\n```python\nimport time\nimport uuid\nimport requests\nfrom flasgger import swag_from\nfrom flask import Flask, jsonify,request\n\napp = Flask(__name__)\n\n@app.route('/api/1/vid', methods=['POST'])\n@swag_from('./register_vehicle.yml')\ndef register_vehicle():\n    args = request.args.to_dict()\n    if 'vin' not in args:\n        return jsonify(result_code=\"failed\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       debug_msg=\"vin is required\",\n                       data={})\n    payload = {\n        \"vin\": args.get(\"vin\", \"chunming12345678997\"),\n        \"color\": args.get(\"color\", \"blue\"),\n        \"plate_number\": args.get(\"plate_number\", \"京D12345\"),\n        \"model\": args.get(\"model\", \"ES8\"),\n        \"misc\": args.get(\"misc\", \"demo\")\n    }\n\n    r = requests.request(\"POST\", \"https://example.com/api/1/in/vehicle/profile\", data=payload)\n    response = jsonify(result_code=\"success\",\n                       request_id=str(uuid.uuid1()),\n                       server_time=int(time.time()),\n                       data=r.json())\n    return response\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。\n\n### 提供Mock数据\n什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。\n\n其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：\n```python\nfrom flask import jsonify, Flask\nfrom flasgger import swag_from\nimport time\nimport uuid\napp = Flask(__name__)\n\nack = {\n    \"data\": {\n        \"ack\": 1\n    },\n    \"request_id\":str(uuid.uuid1()),\n    \"server_time\":int(time.time()),\n    \"result_code\":\"success\"\n}\n\n@app.route(\"/ack\", methods=['GET'])\n@swag_from('./register_vehicle.yml')\ndef get_ack():\n    return jsonify(ack)\n```\n通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。\n\n## 总结\n本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——\"统一测试数据生成平台\"。\n\n后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。","slug":"谈一谈软件测试中的测试数据准备","published":1,"updated":"2019-04-18T07:04:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dutbj90006wf73m83dg8x4","content":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2 id=\"常见的测试数据准备方法\">常见的测试数据准备方法</h2>\n<p>我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3 id=\"基于gui准备测试数据\">基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3 id=\"基于api准备测试数据\">基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3 id=\"基于db准备测试数据\">基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3 id=\"基于mq准备测试数据\">基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3 id=\"基于第三方库准备测试数据\">基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3 id=\"综合运用上述方法准备测试数据\">综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2 id=\"准备测试数据的时机\">准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3 id=\"实时创建on-the-fly\">实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3 id=\"提前准备out-of-box\">提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2 id=\"构造测试数据的痛点及应对\">构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3 id=\"调用封装函数的复杂性\">调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3 id=\"封装函数的版本管理\">封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2 id=\"统一测试数据生成平台\">统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据平台&quot;从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。</p>\n<h3 id=\"提供真实数据\">提供真实数据</h3>\n<p>下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。</p>\n<p>比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。</p>\n<p>首先，使用pipenv创建虚拟环境，安装好Flask框架。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flasky</span><br><span class=\"line\">cd flasky</span><br><span class=\"line\">pipenv --python 3.6</span><br><span class=\"line\">pipenv install flask</span><br></pre></td></tr></table></figure>\n<p>下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify,request</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/api/1/vid', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register_vehicle</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    args = request.args.to_dict()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">'vin'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(result_code=<span class=\"string\">\"failed\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       debug_msg=<span class=\"string\">\"vin is required\"</span>,</span><br><span class=\"line\">                       data=&#123;&#125;)</span><br><span class=\"line\">    payload = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"vin\"</span>: args.get(<span class=\"string\">\"vin\"</span>, <span class=\"string\">\"chunming12345678997\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: args.get(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"blue\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"plate_number\"</span>: args.get(<span class=\"string\">\"plate_number\"</span>, <span class=\"string\">\"京D12345\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"model\"</span>: args.get(<span class=\"string\">\"model\"</span>, <span class=\"string\">\"ES8\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"misc\"</span>: args.get(<span class=\"string\">\"misc\"</span>, <span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r = requests.request(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"https://example.com/api/1/in/vehicle/profile\"</span>, data=payload)</span><br><span class=\"line\">    response = jsonify(result_code=<span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       data=r.json())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。</p>\n<h3 id=\"提供mock数据\">提供Mock数据</h3>\n<p>什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。</p>\n<p>其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> jsonify, Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">ack = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ack\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"request_id\"</span>:str(uuid.uuid1()),</span><br><span class=\"line\">    <span class=\"string\">\"server_time\"</span>:int(time.time()),</span><br><span class=\"line\">    <span class=\"string\">\"result_code\"</span>:<span class=\"string\">\"success\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/ack\", methods=['GET'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ack</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(ack)</span><br></pre></td></tr></table></figure>\n<p>通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。</p>\n<h2 id=\"总结\">总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>测试数据的准备，是软件测试工作中非常重要的环节，无论是手工测试还是自动化测试都避不开测试数据准备工作。今天我们就来聊一聊测试工作中常用的测试数据准备的方法，深入了解各自的优缺点和使用场景，以及测试数据准备工作未来的发展方向。</p>\n</blockquote>\n<h2>常见的测试数据准备方法</h2>\n<p>我总结了一下我曾经过用过的生成测试数据的方法，主要有以下几类：</p>\n<ul>\n<li>基于GUI的测试数据生成方法</li>\n<li>基于API的测试数据生成方法</li>\n<li>基于DB的测试数据生成方法</li>\n<li>基于MQ的测试数据生成方法</li>\n<li>基于第三方库方式的测试数据生成方法</li>\n<li>综合运用上述方法生成测试数据</li>\n</ul>\n<p>接下来，我们一起详细分析一下各种方法的有权点以及适用场景。</p>\n<h3>基于GUI准备测试数据</h3>\n<p>基于GUI界面进行测试数据准备，是最原始的创建测试数据的方法，这种方法其实是采用E2E的方法来执行业务场景，然后得到测试数据。</p>\n<p>比如，测试用户登录功能，那么需要准备的测试数据就是用户账号，为此我们可以通过APP或者WEB端的GUI页面注册新用户，然后用这个用户完成用户登录功能的测试。</p>\n<p>这种方法的优点是简单直接，创建的数据来自于真实的业务流程，最大程度保证了数据的正确性和完整性。在很多手工测试的场景中，这种方法被普遍采用。</p>\n<p>但是，这种方法的缺点也非常明显，主要体现在以下几个方面：</p>\n<ul>\n<li><strong>创建测试数据的效率低，不适合批量生成测试数据。</strong> 因为通过GUI操作每次只能创造一条数据，而且通过手工操作GUI的过程也是比较耗时。</li>\n<li><strong>基于GUI的测试数据生成方法不适合为自动化测试提供数据。</strong> 由于自动化测试往往是通过代码来准备测试数据，而GUI方法生成测试数据的方法不太适合封装成代码被自动化测试用例调用。因为封装GUI方式生成测试数据的方法，本质上是在开发GUI自动化测试用例，而我们知道无论是开发工作量还是执行效率，亦或是稳定性方面，这种方法都是不是最佳的选择。</li>\n<li><strong>会引入不必要的测试依赖。</strong> 比如测试用户登录功能，如果依赖GUI先注册一个用户，那么就意味着注册功能必须是没问题的，引入了依赖。这种情况，从数据库中找到一个已注册的账号来测试登录功能才是最佳选择。</li>\n</ul>\n<p>在前后台配合的手工测试中，比如内容管理系统CMS和手机APP的测试，如果要手工测试手机APP的文章列表功能，那么就可以采用这种方法。除此之外，基于GUI操作生成测试数据的场景并不多。</p>\n<p>基于GUI生成测试数据的方法，有一个非常重要的价值是帮助我们在创建测试数据的过程中，找到创建数据的过程中都调用了哪些API以及修改了哪些DB的表。只有了解了这两个方面，我们后续通过API或者修改DB方式创建测试数据时，才能保证数据的完整性。</p>\n<h3>基于API准备测试数据</h3>\n<p>通过调用API生成测试数据，是目前测试数据生成的主要方法。由于后台接口一般比较稳定，大大提供了测试数据构造的准确性和成功率。调用接口相比GUI操作也能够比较快速的创建测试数据，效率高。另外，由于我们直接给API传递参数，通过参数的组合可以构造成某些GUI方法不能构造出来的测试数据。</p>\n<p>那么，我们如何获取到这些API呢？通常推荐按照下面的顺序，来查找API相关的信息。</p>\n<ol>\n<li><strong>API接口文档。</strong> 通常成熟的开发团队，都会编写API的接口文档，接口文档中会详细描述接口的URI和调用参数，这是最直接有效的办法。</li>\n<li><strong>通过抓包。</strong>  抓包在测试中是非常常用的辅助手段，我们可以在操作APP或者WEB页面的时候，对操作进行抓包，通过对抓取到的请求包，分析接口的各种参数。这也是相对高效的办法。</li>\n<li><strong>查看日志文件。</strong> 对于已经上线的接口，我们可以通过服务的日志，来查看接口调用过程中的URI和参数等内容。</li>\n<li><strong>阅读源码。</strong> 如果前面三种方法都不能用，那么可以在Gitlab上查看开发人员的项目代码，通过阅读代码的方法，找到接口请求的各种参数。</li>\n</ol>\n<p>通过API构造测试数据的方法也不是完美的，主要有几个方面：</p>\n<ol>\n<li><strong>不是所有的数据创建都有对应的API。</strong></li>\n<li><strong>有时候需要顺序调用多个API。</strong> 有时候测试数据之间是有关联关系的，为了保证测试数据的完整性和一致性，需要依次调用多个API，无形中增加了测试数据准备的复杂性。</li>\n</ol>\n<p>调用API创建测试数据，天生适合与自动化测试相结合，在实际的测试实践中，我们往往会把API封装成测试数据准备函数供自动化测试用例使用。当API内部逻辑有修改时，我们依旧可以通过封装函数来准备测试数据，对测试用例来说，是完全透明的。</p>\n<p>这里所说的API指的是基于HTTP协议的Restful API。但是可以扩展到其他协议的各种调用接口，比如MQTT协议、RPC协议等。</p>\n<h3>基于DB准备测试数据</h3>\n<p>通过往数据库中直接插入数据，也是非常常用的构造测试数据的方法。具体做法是，将创建测试数据的SQL语句封装成一个个测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。这种方法有一个非常大的优点是生成测试数据的效率非常高，可以短时间内往数据库中插入大量的测试数据。</p>\n<p>以用户登录功能测试为例，当我们调用API进行用户注册时，这个API会将用户的详细的信息插入到user表和role表两个数据库表中。如果我们采用数据库方式创造数据时，给user表和role表分别插入对应的数据就完成了用户的注册。我们还可以直接使用DB中已有的数据作为我们的测试数据，从而省去了很多操作。</p>\n<p>这里的前提是，你必须知道进行新用户注册时，到底涉及到了哪些数据库的表。最直接的办法就是跟开发同学索要SQL语句，或者查看源代码。</p>\n<p>这种构造测试数据的方法也不是完美的，主要体现在以下几个方面：</p>\n<ol>\n<li><strong>有的测试数据准备涉及到的数据表太多。</strong> 导致封装和维护测试准备函数的成本比较高。</li>\n<li><strong>容易出现数据不完整和不一致。</strong> 比如服务A某一个业务，实际会在服务A的数据库表A和数据库表B中分别插入数据，并且同时会给kafka的某个topic发送数据供服务B消费处理后持久化到服务B的数据库表C中。如果我们漏掉了某个数据库表的插入操作，可能会导致数据的不完整和不一致。</li>\n</ol>\n<p>基于DB准备测试数据的方法，通常作为API方法的补充。</p>\n<h3>基于MQ准备测试数据</h3>\n<p>在微服务架构中，通常会存在通过消息中间件将多个服务进行解耦，为了减少测试工作的依赖，通常会往kafka中构造测试数据。</p>\n<p>比如，两个服务是通过KAFKA进行消息传递的，两个服务分别作为kafka的生成者和消费者。当我们测试作为消费者的服务时，就可以编写kafka的producer代码，往kafka中生产测试所需要的测试数据。具体的做法与通过DB构造测试数据的方式类似，将kafka的producer代码封装成测试数据生成函数，当我们创建数据时，直接调用这些封装好的函数即可。</p>\n<p>这种做法和操作DB并没有本质不同，其优点和缺点也是类似的。</p>\n<h3>基于第三方库准备测试数据</h3>\n<p>我们的测试实践中，经常会需要生成很多随机的数据，对于这类需求，直接使用代码封装成函数生成数据。拿python为例，可以自己结合random()之类的函数随机生成数据，还可以使用faker（<a href=\"https://github.com/joke2k/faker\" target=\"_blank\" rel=\"noopener\">项目地址</a>）这样的第三方库来实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from faker import Factory</span><br><span class=\"line\"></span><br><span class=\"line\">fake = Factory().create(&apos;zh_CN&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">def random_phone_number():</span><br><span class=\"line\">    &apos;&apos;&apos;随机手机号&apos;&apos;&apos;</span><br><span class=\"line\">    return fake.phone_number()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_name():</span><br><span class=\"line\">    &quot;&quot;&quot;随机姓名&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.name()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_address():</span><br><span class=\"line\">    &quot;&quot;&quot;随机地址&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.address()</span><br><span class=\"line\"></span><br><span class=\"line\">def random_email():</span><br><span class=\"line\">    &quot;&quot;&quot;随机email&quot;&quot;&quot;</span><br><span class=\"line\">    return fake.email()</span><br></pre></td></tr></table></figure>\n<p>这类生成测试数据的方法试用的场景是，对数据本身的值不关心但是测试中又必须需要这些参数的情况。</p>\n<h3>综合运用上述方法准备测试数据</h3>\n<p>在实际工作中，很少使用单一的方法就能满足测试的需求，往往是综合运用上述各种方法、一个典型的应用场景是，通过API生成最基础的测试数据，比如车辆的vid，然后使用数据库和MQ的方法是生成符合测试需要的车辆状态数据。</p>\n<p>我以上报车辆状态数据的测试为例子，来分享一下具体的如何将API调用和MQTT协议的方法结合起来构造测试数据。</p>\n<p>比如我们要测试云端对车辆上报的报警数据的处理是否符合要求。首先，我们需要通过调用注册Vechile ID的接口来注册一台车并且获得车辆证书，通过调用这个接口我们可以得到一个车辆的ID以及证书数据。再结合MQTT协议产生车辆的报警数据。</p>\n<p>为了构造测试数据的更加便捷，我们往往是对上面的操作进行封装。用封装后的方法产生测试数据。</p>\n<h2>准备测试数据的时机</h2>\n<p>前面介绍了准备测试数的方法，那么应该在什么时候创建好所需要的测试数据。是在测试用例执行中创建测试数据（On-the-Fly方法）还是在测试执行前就准备好测试数据（Out-of-Box方法）。</p>\n<p>其实，创建测试数据的时机要根据实际的需要来。主要参考一下几个因素：</p>\n<ol>\n<li><strong>创建测试数据所需要的时间。</strong>  如果创建数据需要花很长时间，那么最好采用Out-of-Box方法，在测试执行之前就准备好，以减少整个测试执行的时间。</li>\n<li><strong>测试数据是否需要经常变动。</strong> 如果测试数据不需要经常变动，那么最好采用Out-of-Box方法。如果事先生成数据在测试用例中会失效，比如具有有效期的数据，那么就适合采用On-the-Fly方法，在测试执行中创建。</li>\n<li><strong>测试数据是否存在于很多系统。</strong>  如果测试数据需要在很多系统中都要创建各自的部分，各自又有很多依赖关系，那么就适合Out-of-Box方法。因为在测试用例执行中创建，会导致测试代码比较臃肿，不够清晰。</li>\n<li><strong>构造测试数据的服务是否稳定。</strong> 在不太稳定的服务中构造测试数据，会产生大量构造测试数据失败的情况。这种情况下采用Out-of-Box方法还是比较明智的。</li>\n</ol>\n<p>接下来，我们详细看一下On-the-Fly方法和Out-of-Box方法各自的特点，以及适用场景。</p>\n<h3>实时创建（On-the-Fly）</h3>\n<p>实时生成测试数据的方法，指的是在测试用例代码执行过程中即时创建测试数据。比如，测试车辆驾驶中，不能执行远程控制命令的场景。在测试执行中，可以通过封装的MQ方法设置测试车辆的车辆状态处于驾驶中，接下来就可以测试远程执行命令了。</p>\n<p>On-the-Fly方法创造的测试数据通常是对每一个测试用例起作用的，不同的测试用例都有自己专属的测试数据。像这种车辆状态数据就适合采用On-the-Fly方法创造，这种状态数据通常是每个测试用例都不同。这种构造测试数据的好处是，避免测试数据在测试用例执行前被修改而产生非预期的测试结果。这样的测试数据使用完之后，通常在测试用例结束之后，恢复成原始数据，避免影响其他测试用例。</p>\n<p>在自动化测试发展早期，测试实践中通常都会这种方法，也是比较好的方法。他解决了测试用例之间数据之间干扰的问题，也避免了测试完之后的脏数据问题。但是随着软件架构的发展，以及测试频率的提高，这种方式的弊端也逐渐显示出来了，主要有以下几个方面：<br>\n<strong>首先，有的测试数据比较耗时。</strong> 在测试用例执行过程中实时创建测试数据，会导致测试用例执行的时间被拉长。如果测试用例特别多，测试频率又特别高，那么测试时间就变得特别长，这显然不适合现在互联网软件的迭代节奏。为了解决测试耗时的问题，可以采用Out-of-Box方法。<br>\n<strong>其次，测试数据本身之间复杂的关联性导致构造困难。</strong> 很多时候，你为了测试某一个场景，需要构造一堆相关联的测试数据，也是偏向业务链后台的测试数据，这个问题越明显。</p>\n<p>比如，要测试被授权人对车执行远程控制命令的场景。会需要车主账号、被授权人账号、车辆ID、车辆ID与车主账号绑定，车主给被授权人授权车辆等前置数据。如果在测试用例执行中准备这些测试数据，那肯定是崩溃的。如果每一个测试用例都这么做，一定会导致测试时间变得非常长。为了解决这个问题，可以考虑将一部分稳定的数据事先创建好，比如车主账号、被授权人账号、车辆ID以及授权关系等数据。</p>\n<p><strong>微服务架构的流行导致成功生成测试数据的稳定性降低</strong>  现在大量互联网应用采用微服务架构，不同功能划分为更多的微服务独立开发和部署，很多时候测试环境里面，这些微服务并不是100%可用的。也就是说，不是任何时候构造测试数据都能成功。比如你测试的微服务B，需要依赖微服务A构造数据，而这时候正好微服务A不可用，这就block了微服务B的测试。</p>\n<p>为了解决上面的问题，事先准备测试数据的Out-of-Box方法，就有了用武之地。</p>\n<h3>提前准备（Out-of-Box）</h3>\n<p>Out-of-Box方法，指的是在测试用例执行前，就已经准备好了所用的全部或者部分测试数据，而不是在测试用例中实施创建。因此，执行测试用例时候，可以节省不少准备测试数据的时间，同时也避免因为依赖的测试数据准备服务不可用导致测试被block的情况。</p>\n<p>那么Out-of-Box方法是否也存在缺点呢？</p>\n<p>最主要的问题是**“有效性”**问题，就是有测试执行中发现测试数据不可用的风险。比如，测试被授权人远程执行车控命令的场景，当你执行测试时，发现被授人的身份已经被车主账号删掉了，这样就导致测试用例执行失败，也就不能顺利完成测试了。</p>\n<p>由此可见，这些实现创建好的测试数据，有可能在测试用例执行时已经不可用了，因为这些数据有可能已经进行了非预期的修改。比如，在其他测试用例执行时，使用了这个测试数据，并修改了这些数据的状态。</p>\n<p>为了解决这个问题，我们通常采用优化测试管理流程，让不同的测试人员、测试业务都有自己独立的测试数据，并且统计在confluence、jira或者其他公共平台上，大家严格遵守，不要乱用测试数据。</p>\n<p>另外，Out-of-Box方法不适合准备，只能被使用一次的测试数据，只会使用一次的测试数据还是采用On-the-Fly方法准备比较合适。</p>\n<p>实际工作中，我们通常是采用On-the-fly 和 Out-of-box 这两种方式相结合的方式来准备测试数据。我们可以根据测试目的的不同，将测试数据划分为“固定数据”和“易变数据”。比如某些测试场景中，车辆ID、车辆Profile、车主账号等信息是相对稳定、不经常变化的数据，那么我们可以将这些测试数据称为“固定数据”，这类数据适合采用Out-of-box方式创建。但是在某些测试场景中，比如车辆ID的注销，车辆Profile的变更测试，那么车辆ID、车辆Profile就不能叫做“固定数据”而是应该叫做“灵活数据”，这类数据适合采用 On-the-fly 方式准备。</p>\n<p>综合运用这两类方法，可以满足大部分测试数据准备的场景。可以解决准备测试数据耗时长、准备测试数据成功率不高等问题。</p>\n<h2>构造测试数据的痛点及应对</h2>\n<p>前面，我们分析了两种准备测试数据的时机以及各自的优缺点。那么我们实际工作中，准备测试数据的工作有哪些痛点，我们又该如何解决呢？</p>\n<h3>调用封装函数的复杂性</h3>\n<p>前面提到封装API到一个函数，然后调用这个函数来构造测试数据的方法。但是这种封装方式会有问题，就是如果参数非常多，那么你调用它来构造数据时，就要准备这些参数。如果这些参数是基本类型的话还好，如果参数本身也是对象的话，可能就会更加麻烦了，因为你要创建这些对象。而创建这些对象，有可能要继续调用其他封装的函数，从而牵连出一系列函数调用的操作。</p>\n<p>比如，调用这样一个封装了注册车辆vid的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin, color, plate_number, model, misc):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">color=&quot;blue&quot;</span><br><span class=\"line\">plate_number=&quot;D12345&quot;</span><br><span class=\"line\">model=&quot;PAD8&quot;</span><br><span class=\"line\">misc=&quot;demo&quot;</span><br><span class=\"line\">vid = register_vehicle(vin, color, plate_number, model, misc)</span><br></pre></td></tr></table></figure>\n<p>由此可见，每次使用封装的函数准备测试数据时，我们要给函数传递所有的参数。其实大多数测试场景下，所有参数都可以给一个默认值，用这个函数准备测试数据时，只需要给那些有明确要求的参数传值，其他参数保持默认值即可。这样封装的函数就变成这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def  register_vehicle(vin=&quot;chunming&quot;, color=&quot;blue&quot;, plate_number=&quot;D12345&quot;, model, misc=&quot;demo&quot;):</span><br><span class=\"line\">    # 封装的处理过程</span><br><span class=\"line\">\tretrun vid</span><br><span class=\"line\">\t</span><br><span class=\"line\">vin=&quot;chunming12345678997&quot;</span><br><span class=\"line\">vid = register_vehicle(vin=vin)</span><br></pre></td></tr></table></figure>\n<p>这样，大大减少了调用封装函数的成本。当测试用例中只需要一个特定vin的车辆时，只需要给register_vehicle传递参数vin的值，其他的测试用例不关心的参数都可以保持默认值。</p>\n<h3>封装函数的版本管理</h3>\n<p>通常我们封装函数是给所有的测试项目共同使用的，这样才能最大化封装函数的价值。共享封装函数的办法通常是将其打包，然后在其他项目中引用。如果你的测试项目是使用Python，那么可以将封装的函数用setuptools打包上传到公司的Pypi平台，在测试的项目中用pip安装。如果你的测试是使用Java，可用Maven将封装函数打成Jar包并上传到公司的私有仓库，在测试项目中的pom.xml中引入jar包就好了。</p>\n<p>现在的互联网应用版本迭代更新特别快，导致封装函数也要对应的迭代更新。这就会产生数据准备函数的包升级更新比较频繁，包的版本号就要随着变化。所以引用了这些数据准备函数包的项目，就要更新包的版本。给使用者带来了一些麻烦。</p>\n<p>为了解决项目对封装函数的依赖问题，我们可以将其做成Restful API，这样使用者就免去了频繁更新这些依赖包的麻烦。而且Restful API天生的跨平台支持，让调用方不管是用Java写测试用例还是Python写测试用例，都可以得到完美的支持。接下来我们就详细介绍一下基于Restful API的测试数据准备方案。</p>\n<h2>统一测试数据生成平台</h2>\n<p>前面介绍了创建测试数据的主要方法、创建测试数据的时机，以及测试数据生成中的痛点。随着测试技术的发展，测试数据准备技术与架构也需要逐步进化，来满足互联网微服务架构的发展趋势以及快速迭代的特点。</p>\n<p>现在业界，将测试数据准备的工作进行平台化，逐渐成为测试数据准备方案的发展方向。而Restful API的测试数据准备方案，正好适合平台化的发展方向。我们可以将基于 Java 开发的数据准备函数用 Spring Boot包装成Restful API，或者将基于Python开发的数据准备函数用<a href=\"http://flask.pocoo.org/\" target=\"_blank\" rel=\"noopener\">Flask</a>或者<a href=\"https://www.django-rest-framework.org/\" target=\"_blank\" rel=\"noopener\">Django REST framework</a>包装成Restful API。</p>\n<p>这样一来，测试人员可以通过Restful API调用来准备测试数据了，由于HTTP协议是跨平台的，所以几乎所有的测试框架都可以直接使用这些Restful API准备测试数据。由于使用Restful API提供测试数据，这样方便我们将提供各类测试数据的服务整合到一起，形成“统一测试数据生成平台”。结合Swagger提供的界面化文档，可以方便看到接口调用的方法，并且可以直接在界面上调用接口生成数据。既满足自动化测试的需要，也能满足手工测试的需求。</p>\n<p>目前为止，我们将测试数据准备工作进行了服务化，下图就是一个统一测试数据生成平台的Restful API 界面：<br>\n<img src=\"/img/article/test-data-platform.png\" alt=\"\"><center>统一测试数据平台Restful API UI 界面</center></p>\n<p>&quot;统一测试数据平台&quot;从提供的测试数据特性来分，可以分为真实数据和Mock数据。真实数据就是封装微服务的接口，在业务系统中实际产生真实的业务数据用作测试数据。Mock数据是指通过mock技术产生非实际业务中的数据、这类数据一般用于解决服务依赖问题。</p>\n<h3>提供真实数据</h3>\n<p>下面通过Flask Web框架来介绍如何通过封装业务操作提供真实的测试数据实践。</p>\n<p>比如，我要测试远程控制车辆的API，其中有一个测试用例是验证在车辆在行驶中时不能进行远程控制。针对这个测试用例，我们需要的测试数据有被控制车辆的ID以及车辆状态。下面以准备车辆ID的Restful API为例，介绍具体的实现方式。</p>\n<p>首先，使用pipenv创建虚拟环境，安装好Flask框架。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir flasky</span><br><span class=\"line\">cd flasky</span><br><span class=\"line\">pipenv --python 3.6</span><br><span class=\"line\">pipenv install flask</span><br></pre></td></tr></table></figure>\n<p>下面这段代码是封装了业务接口api/1/in/vehicle/profile的代码片段。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, jsonify,request</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route('/api/1/vid', methods=['POST'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register_vehicle</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    args = request.args.to_dict()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">'vin'</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> args:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonify(result_code=<span class=\"string\">\"failed\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       debug_msg=<span class=\"string\">\"vin is required\"</span>,</span><br><span class=\"line\">                       data=&#123;&#125;)</span><br><span class=\"line\">    payload = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"vin\"</span>: args.get(<span class=\"string\">\"vin\"</span>, <span class=\"string\">\"chunming12345678997\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"color\"</span>: args.get(<span class=\"string\">\"color\"</span>, <span class=\"string\">\"blue\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"plate_number\"</span>: args.get(<span class=\"string\">\"plate_number\"</span>, <span class=\"string\">\"京D12345\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"model\"</span>: args.get(<span class=\"string\">\"model\"</span>, <span class=\"string\">\"ES8\"</span>),</span><br><span class=\"line\">        <span class=\"string\">\"misc\"</span>: args.get(<span class=\"string\">\"misc\"</span>, <span class=\"string\">\"demo\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    r = requests.request(<span class=\"string\">\"POST\"</span>, <span class=\"string\">\"https://example.com/api/1/in/vehicle/profile\"</span>, data=payload)</span><br><span class=\"line\">    response = jsonify(result_code=<span class=\"string\">\"success\"</span>,</span><br><span class=\"line\">                       request_id=str(uuid.uuid1()),</span><br><span class=\"line\">                       server_time=int(time.time()),</span><br><span class=\"line\">                       data=r.json())</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    app.run(debug=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，提供默认参数，只需要传递测试感兴趣的参数就可以，不感兴趣的数据保持默认值即可。结合flasgger提供的swag_from装饰器，给接口编写文档，让封装的接口易懂和易用。</p>\n<h3>提供Mock数据</h3>\n<p>什么情况下需要Mock数据，比如：服务A调用服务B的Restful API，传递给服务B数据，服务B会根据数据情况返回给服务A一个ACK值。当服务B没有Ready时候，我们就需要模拟服务B的行为。</p>\n<p>其实产生这种Mock数据，与前面介绍的产生实际业务数据，方法上并没有不同。只是在Restful API的response构造上，前者构造产生的数据来自与真实的业务接口，而Mock的数据是根据测试需求伪造的。模拟前面提到的服务B的行为，以Flask方案为例，就是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> jsonify, Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flasgger <span class=\"keyword\">import</span> swag_from</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">ack = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"ack\"</span>: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"request_id\"</span>:str(uuid.uuid1()),</span><br><span class=\"line\">    <span class=\"string\">\"server_time\"</span>:int(time.time()),</span><br><span class=\"line\">    <span class=\"string\">\"result_code\"</span>:<span class=\"string\">\"success\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(\"/ack\", methods=['GET'])</span></span><br><span class=\"line\"><span class=\"meta\">@swag_from('./register_vehicle.yml')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_ack</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonify(ack)</span><br></pre></td></tr></table></figure>\n<p>通过控制上面ack的内容，就可以模拟服务B的各种Response了。如果将这个ack的内容存入数据库中，让get_ack函数从数据库中取得ack并返回。再写一个接口用于往数据库中写入ack，那么就可以在自动化测试中随意控制ack的返回内容了。</p>\n<h2>总结</h2>\n<p>本篇文章我们梳理了测试数据准备的各种方法，并分析了各自的优缺点及适用场景。测试数据准备的时机上看，对于不常改变的数据适合采用提前准备的方法，对于经常变化的数据在测试用例中准备更好。对测试工作中数据准备的痛点进行了剖析并给出了应对方案。最后，给出了解决测试数据生成痛点的终极解决方案——“统一测试数据生成平台”。</p>\n<p>后面，我将专门写一篇博文，详细介绍如何从0搭建统一测试数据平台。</p>\n"},{"title":"通过容器化Python web应用了解Docker容器核心功能","catalog":true,"toc_nav_num":true,"date":"2019-05-12T12:51:24.000Z","subtitle":"通过实战了解Docker核心功能","header-img":"/img/article_header/tizi.jpg","catagories":["Docker"],"_content":"> 本篇文章通过一个典型的Python web应用，带你了解Docker的核心功能。需要依赖一台已经安装了Docker的Linux虚拟机。\n\n## 构建一个镜像\n首先我们准备一个应用。新建一个本文文件，起名叫 app.py，里面写入下面的内容，实现一个简单的web应用：\n```pythonstub\nfrom flask import Flask\nimport socket\nimport os\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    html = \"<h3>Hello {name}!</h3>\" \\\n           \"<b>Hostname:</b> {hostname}<br/>\"           \n    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname())\n    \nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80)\n```\n在这段代码中，使用 Flask 框架启动了一个 Web 服务器，而它唯一的功能是：如果当前环境中有“NAME”这个环境变量，就把它打印在“Hello”后，否则就打印“Hello world”，最后再打印出当前环境的 hostname。\n这个应用的依赖文件requirements.txt存在于与其同级的目录中，内容是：\n```shell\ncat requirements.txt\nFlask\n```\n将这样一个应用在容器中跑起来，需要制作一个容器镜像。Docker提供了一种Dockerfile文件，来描述镜像的构建过程。下面的代码存在于与上面的应用（app.py）同级目录下的Dockerfile中。\n```text\n# 使用官方提供的python:3.6-alpine镜像，作为我们这个镜像的基础镜像，这样我们的镜像就有了python3.6环境\nFROM python:3.6-alpine\n\n# 将工作目录切换为 /app\nWORKDIR /app\n\n# 将当前目录下的所有内容复制到镜像的 /app 下\nADD . /app\n\n# 使用 pip 命令安装这个应用所需要的依赖，RUN 指令就是在容器里执行 shell 命令的意思。\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# 允许外界访问容器的 80 端口\nEXPOSE 80\n\n# 设置环境变量\nENV NAME World\n\n# 设置容器进程为：python app.py，即：这个 Python 应用的启动命令\nCMD [\"python\", \"app.py\"]\n```\n这个Dockerfile文件的内容，描述了我们所要构建的 Docker 镜像。Dockerfile中每一行都是按顺序处理的。这个Dockerfile中用到的指令的具体含义已经在以注释的方式写在了Dockerfile中。\n\n需要再详细介绍一下CMD指令。CMD指定了`python app.py`为这个容器启动后执行的进程。因为Dockerfile中使用WORKDIR切换了容器的工作路径是/app，所以 app.py 的实际路径是 /app/app.py。CMD [\"python\", \"app.py\"] 等价于 \"docker run <imgname> python app.py\"。\n\n另外，在使用 Dockerfile 时，还有一种 ENTRYPOINT 指令。它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：\"ENTRYPOINT CMD\"。\n\n默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：`/bin/sh -c`。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c \"python app.py\"，即 CMD 的内容就是 ENTRYPOINT 的参数。正是基于这样的原理，Docker 容器的启动进程为实际为 ENTRYPOINT，而不是 CMD。\n\n需要注意的是，Dockerfile 里的指令并不都是只在容器内部的操作。就比如 ADD，它指的是把当前目录（即 Dockerfile 所在的目录）里的文件，复制到指定容器内的目录当中。\n\n根据前面的描述，现在我们的整个应用的目录结构应该如下这样：\n```shell\nls\nDockerfile  app.py   requirements.txt\n```\n现在我们执行下面的指令构建镜像：\n```shell\ndocker build -t helloworld .\n```\n其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。docker build 会自动加载当前目录下的 Dockerfile 文件，然后按照顺序执行Dockerfile文件中的指令。\n\nDockerfile 中的每个指令执行后，都会生成一个对应的镜像层。\n\n上面的命令执行完成后，就形成了一个镜像。可以通过下面的指令查看：\n```text\ndocker image ls\n\nREPOSITORY    TAG        IMAGE ID      CREATED             SIZE\nhelloworld    latest     5bacb9617bcf  7 minutes ago       89.8MB\n```\n还可以通过 `docker inspect helloworld:latest` 查看镜像的元信息。\n\n## 运行镜像\n有了镜像，就可以通过下面的指令来运行容器了。\n```text\ndocker run -p 5000:80 helloworld\n```\n在这一句命令中，镜像名 helloworld 后面，什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：\n```text\ndocker run -p 5000:80 helloworld python app.py\n```\n如果上面的指令执行后，能够输出下面的内容，则表示容器启动成功了：\n```text\n * Serving Flask app \"app\" (lazy loading)\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)\n```\n可以通过运行`docker ps`指令，查看运行中的容器。\n```text\ndocker ps\n\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES\na242ecaf6cf6        helloworld          \"python app.py\"     3 minutes ago       Up 3 minutes        0.0.0.0:5000->80/tcp   dazzling_khayyam\n```\n从输出中可以看到，容器的ID，容器是基于哪个镜像的启动的，容器中的进程，容器的启动时间及端口映射情况。\n\n从现在看，容器已经正确启动，我们使用curl命令通过宿主机的IP和端口号，来访问容器中的web应用：\n```text\ncurl localhost:5000\n<h3>Hello World!</h3><b>Hostname:</b> a242ecaf6cf6<br/>\n```\n还有一种访问容器中应用的方法是使用容器的IP和应用端口号，应用的端口号我们已经在Dockerfile中指定为80，那么容器的IP如何获取呢？\n\n依然是使用`docker inspect CONTAINER ID`命令查看容器的元数据。容器的IP地址就在其中。\n\n## 分享镜像 \n大家一定用过代码分享平台GitHub，在Docker世界中分享镜像的平台是[Docker Hub](https://hub.docker.com/)，它\"学名\"叫镜像仓库（Repository）。\n\n为了能够上传镜像，首先需要注册一个 Docker Hub 账号，然后使用 docker login 命令登录:\n```text\n$ docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: liuchunming\nPassword:\nLogin Succeeded\n```\n在push到Docker Hub之前，需要先给镜像指定一个版本号：\n```text\ndocker tag helloworld liuchunming/helloworld:v1\n```\nliuchunming是我在Docker Hub 上的账户名。v1是我给这个镜像本次起的版本号。\n\n接着执行下面的指令就可以镜像push到Docker Hub上了：\n```text\ndocker push liuchunming/helloworld:v1\n```\n一旦提交到Docker Hub上，其他人就可以通过`docker pull liuchunming/helloworld:v1`指令将镜像下载下来了。\n\n在企业内部，也可以搭建一个跟 Docker Hub 类似的镜像存储系统。感兴趣的话，可以查看VMware 的 Harbor 项目。\n\n## 进入正在运行的容器中玩玩\n运行web服务的容器，通常是以后台进程启动的。就是在`docker run`指令后面加上-d选项。比如以后台方式运行上面的web容器：\n```text\ndocker run -d -p 5000:80 helloworld\n```\n如果你想进入到一个正在运行的容器做一些操作，可以通过`docker exec`指令。我们需要先通过`docker ps`命令查看容器的ID,然后执行下面的命令。\n```text\ndocker exec -it 1695ed10e2cb75e /bin/sh\n```\n-it选项指的是连接到容器后，启动一个terminal(终端)并开启input(输入)功能。`/bin/sh`表示进入到容器后执行的命令。\n\n现在我们就可以在终端上进行一些操作了，比如在容器中新建一个readme.md文件：\n```text\n/app # ps\nPID   USER     TIME  COMMAND\n    1 root      0:00 python app.py\n   24 root      0:00 /bin/sh\n   29 root      0:00 ps\n/app# touch readme.md\n/app# exit\n```\n我们还可以将正在运行的容器，commit成新的镜像。\n```text\ndocker commit 1695ed10e2cb75e liuchunming033/helloworld:v2\n```\ndocker exec 的实现原理，其实是利用了容器的三大核心技术之一的Namespace。一个进程可以选择加入到某个进程（运行中的容器）已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。更细节的原理这里不在细究。\n\n还有一种进入容器的方法是使用`docker attach container_id`，不过这种方法不建议使用，因为它有两个明显的缺点：\n - 当多个窗口同时attach到同一个容器时，所有的窗口都会同步的显示，假如其中的一个窗口发生阻塞时，其它的窗口也会阻塞。\n - attach必须是登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，会导致容器停止。\n\n## 容器与宿主机之间如何共享文件\n容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。但是我们使用过程中经常会遇到这样两个问题：\n\n- 容器里进程新建的文件，怎么才能让宿主机获取到？\n\n- 宿主机上的文件和目录，怎么才能让容器里的进程访问到？\n\n这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改。\n\n在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：\n```text\ndocker run -v /test ...\ndocker run -v /home:/test ...\n```\n而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 /test 目录。\n\n只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 `/var/lib/docker/volumes/[VOLUME_ID]/_data`，然后把它挂载到容器的 /test 目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。\n\n启动容器时，给他声明一个volume\n```text\ndocker run -d -v /test helloworld\n```\n容器启动之后，我们来查看一下这个容器 的Volume 在宿主机上的对应的目录:\n```shell\ndocker volume ls\nDRIVER              VOLUME NAME\nlocal               dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3\n```\n或者执行`docker inspect CONTAINER_ID`命令查看，命令输出的Mounts字段中Source的值就是宿主机上的目录：\n```text\n\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3\",\n                \"Source\": \"/var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\",\n                \"Destination\": \"/test\",\n                \"Driver\": \"local\",\n                \"Mode\": \"\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n然后，查看宿主机上的路径：\n```\nls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\n```\n这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：\n```text\ndocker exec -it cf53b766fa6f /bin/sh\ncd test/\ntouch text.txt\n```\n这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里了：\n```text\nls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\ntext.txt\n```\n因为容器运行时产生的文件，在容器停止后将会消失。因此，将容器的目录映射到宿主机的某个目录，一个重要使用场景是持久化容器中产生的文件，比如应用的日志。\n\n## 给容器加上资源限制\n其实容器是运行在宿主机上的特殊进程，多个容器之间是共享宿主机的操作系统内核的。默认情况下，容器并没有被设定使用操作系统资源的上限。\n\n有些情况下，我们需要限制容器启动后占用的宿主机操作系统的资源。Docker可以利用Linux Cgroups机制可以给容器设置资源使用限制。\n\nLinux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正是利用这个特性限制容器使用宿主上的CPU、内存。\n\n下面启动容器的方式，给这个 Python 应用加上 CPU 和 Memory 限制：\n```text\ndocker run -it --cpu-period=100000 --cpu-quota=20000 -m 300M helloworld\n```\n--cpu-period和--cpu-quota组合使用来限制容器使用的CPU时间。表示在--cpu-period的一段时间内，容器只能被分配到总量为 --cpu-quota 的 CPU 时间。-m选项则限制了容器使用宿主机内存的上限。\n\n上面启动容器的命令，将容器使用的CPU限制设定在最高20%，内存使用最多是300MB。\n\n## 容器的启动、重启、停止与删除\n前面我们使用过`docker ps` 查看当前运行中的容器，如果加上 -a 选项，则可以查看运行中和已经停止的所有容器。现在，看一下我的系统中目前的所有容器：\n```text\n$ docker ps -a\nCONTAINER ID   IMAGE        COMMAND          CREATED      STATUS                 PORTS                  NAMES\n525a8c3fc769   helloworld   \"python app.py\"  4 hours ago  Up 3 minutes           80/tcp                 hardcore_feistel\n1695ed10e2cb   helloworld   \"python app.py\"  4 hours ago  Up 3 minutes           0.0.0.0:5000->80/tcp   focused_margulis7\na242ecaf6cf6   helloworld   \"python app.py\"  5 hours ago  Exited (0) 4 hours ago                        dazzling_khayyam\nbe0439b30b2a   helloworld   \"python app.py\"  5 hours ago  Created                                       vigilant_lalande\n```\n从输出中可以看到目前有四个容器，有两个容器处于Up状态，也就是处于运行中的状态，一个容器处于Exited(0)状态，也就是退出状态，一个处于Created状态。\n\n这里补充说明一下docker ps -a的输出结果，一共包含7列数据，分别是 CONTAINER ID、IMAGE、COMMAND、CREATED、STATUS、PORTS和NAMES。 这些列的含义分别如下所示： \n- CONTAINER ID：容器ID，唯一标识容器 \n- IMAGE：创建容器时所用的镜像 \n- COMMAND：在容器最后运行的命令 \n- CREATED：容器创建的时间 \n- STATUS：容器的状态 \n- PORTS：对外开放的端口号 \n- NAMES：容器名（具有唯一性，docker负责命名） \n获取到容器的ID之后，可以对容器的状态进行修改，比如容器1695ed10e2cb进行停止、启动、重启：\n```text\ndocker stop 1695ed10e2cb\ndocker start 1695ed10e2cb\ndocker restart 1695ed10e2cb\n```\n删除容器，有两种操作：\n```text\ndocker rm 1695ed10e2cb\ndocker rm -f 1695ed10e2cb\n```\n不带-f选项，只能删除处于非Up状态的容器，带上-f则可以删除处于任何状态下的容器。\n\nDocker容器状态的流转关系，可以下面这张图：\n![](/img/article/container-status.jpg)\n这张图对容器的生命周期有了清晰的描述，总结了容器各种状态之间是如何转换的。\n\n需要注意一点是容器可以先创建容器，稍后再启动。 也就是可以先执行`docker create` 创建容器（处于 Created 状态），再通过`docker start` 以后台方式启动容器。 docker run 命令实际上是 docker create 和 docker start 的组合。\n\n## 维持容器始终保持运行状态\n\ndocker run指令有一个参数`--restart`，在容器中启动的进程正常退出或发生OOM时， docker 会根据 --restart 的策略判断是否需要重启容器。但如果容器是因为执行 docker stop 或docker kill 退出，则不会自动重启。\n\ndocker支持如下restart策略：\n\n- no – 容器退出时不要自动重启。这个是默认值。\n- on-failure[:max-retries] – 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。\n- always – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启容器，不管容器当时的状态如何。\n- unless-stopped – 不管退出状态码是什么始终重启容器。不过当daemon启动时，如果容器之前已经为停止状态，不启动它。\n\n在每次重启容器之前，不断地增加重启延迟（上一次重启的双倍延迟，从100毫秒开始），来防止影响服务器。这意味着daemon将等待100ms,然后200 ms, 400 ms, 800 ms, 1600 ms等等，直到超过on-failure限制，或执行docker stop或docker rm -f。\n\n如果容器重启成功（容器启动后并运行至少10秒），然后delay重置为默认的100ms。\n\n重启策略示例：\n```text\ndocker run --restart=always 1695ed10e2cb # restart策略为always，使得容器退出时,docker将重启它。并且是无限制次数重启。\ndocker run --restart=on-failure:10 redis #restart策略为on-failure,最大重启次数为10的次。容器以非0状态连续退出超过10次，docker将中断尝试重启这个容器。\n```\n可以通过docker inspect来查看已经尝试重启容器了多少次。例如，获取容器1695ed10e2cb的重启次数:\n```text\ndocker inspect -f \"{{ .RestartCount }}\" 1695ed10e2cb\n```\n或者获取上一次容器重启时间：\n```\ndocker inspect -f \"{{ .State.StartedAt }}\" 1695ed10e2cb\n```\n\n## 总结\n本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。\n","source":"_posts/通过容器化Python web应用了解Docker容器核心功能.md","raw":"---\ntitle: \"通过容器化Python web应用了解Docker容器核心功能\"\ncatalog: true\ntoc_nav_num: true\ndate: 2019-05-12 20:51:24\nsubtitle: \"通过实战了解Docker核心功能\"\nheader-img: \"/img/article_header/tizi.jpg\"\ntags:\n- Docker\ncatagories:\n- Docker\n---\n> 本篇文章通过一个典型的Python web应用，带你了解Docker的核心功能。需要依赖一台已经安装了Docker的Linux虚拟机。\n\n## 构建一个镜像\n首先我们准备一个应用。新建一个本文文件，起名叫 app.py，里面写入下面的内容，实现一个简单的web应用：\n```pythonstub\nfrom flask import Flask\nimport socket\nimport os\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    html = \"<h3>Hello {name}!</h3>\" \\\n           \"<b>Hostname:</b> {hostname}<br/>\"           \n    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname())\n    \nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=80)\n```\n在这段代码中，使用 Flask 框架启动了一个 Web 服务器，而它唯一的功能是：如果当前环境中有“NAME”这个环境变量，就把它打印在“Hello”后，否则就打印“Hello world”，最后再打印出当前环境的 hostname。\n这个应用的依赖文件requirements.txt存在于与其同级的目录中，内容是：\n```shell\ncat requirements.txt\nFlask\n```\n将这样一个应用在容器中跑起来，需要制作一个容器镜像。Docker提供了一种Dockerfile文件，来描述镜像的构建过程。下面的代码存在于与上面的应用（app.py）同级目录下的Dockerfile中。\n```text\n# 使用官方提供的python:3.6-alpine镜像，作为我们这个镜像的基础镜像，这样我们的镜像就有了python3.6环境\nFROM python:3.6-alpine\n\n# 将工作目录切换为 /app\nWORKDIR /app\n\n# 将当前目录下的所有内容复制到镜像的 /app 下\nADD . /app\n\n# 使用 pip 命令安装这个应用所需要的依赖，RUN 指令就是在容器里执行 shell 命令的意思。\nRUN pip install --trusted-host pypi.python.org -r requirements.txt\n\n# 允许外界访问容器的 80 端口\nEXPOSE 80\n\n# 设置环境变量\nENV NAME World\n\n# 设置容器进程为：python app.py，即：这个 Python 应用的启动命令\nCMD [\"python\", \"app.py\"]\n```\n这个Dockerfile文件的内容，描述了我们所要构建的 Docker 镜像。Dockerfile中每一行都是按顺序处理的。这个Dockerfile中用到的指令的具体含义已经在以注释的方式写在了Dockerfile中。\n\n需要再详细介绍一下CMD指令。CMD指定了`python app.py`为这个容器启动后执行的进程。因为Dockerfile中使用WORKDIR切换了容器的工作路径是/app，所以 app.py 的实际路径是 /app/app.py。CMD [\"python\", \"app.py\"] 等价于 \"docker run <imgname> python app.py\"。\n\n另外，在使用 Dockerfile 时，还有一种 ENTRYPOINT 指令。它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：\"ENTRYPOINT CMD\"。\n\n默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：`/bin/sh -c`。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c \"python app.py\"，即 CMD 的内容就是 ENTRYPOINT 的参数。正是基于这样的原理，Docker 容器的启动进程为实际为 ENTRYPOINT，而不是 CMD。\n\n需要注意的是，Dockerfile 里的指令并不都是只在容器内部的操作。就比如 ADD，它指的是把当前目录（即 Dockerfile 所在的目录）里的文件，复制到指定容器内的目录当中。\n\n根据前面的描述，现在我们的整个应用的目录结构应该如下这样：\n```shell\nls\nDockerfile  app.py   requirements.txt\n```\n现在我们执行下面的指令构建镜像：\n```shell\ndocker build -t helloworld .\n```\n其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。docker build 会自动加载当前目录下的 Dockerfile 文件，然后按照顺序执行Dockerfile文件中的指令。\n\nDockerfile 中的每个指令执行后，都会生成一个对应的镜像层。\n\n上面的命令执行完成后，就形成了一个镜像。可以通过下面的指令查看：\n```text\ndocker image ls\n\nREPOSITORY    TAG        IMAGE ID      CREATED             SIZE\nhelloworld    latest     5bacb9617bcf  7 minutes ago       89.8MB\n```\n还可以通过 `docker inspect helloworld:latest` 查看镜像的元信息。\n\n## 运行镜像\n有了镜像，就可以通过下面的指令来运行容器了。\n```text\ndocker run -p 5000:80 helloworld\n```\n在这一句命令中，镜像名 helloworld 后面，什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：\n```text\ndocker run -p 5000:80 helloworld python app.py\n```\n如果上面的指令执行后，能够输出下面的内容，则表示容器启动成功了：\n```text\n * Serving Flask app \"app\" (lazy loading)\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)\n```\n可以通过运行`docker ps`指令，查看运行中的容器。\n```text\ndocker ps\n\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES\na242ecaf6cf6        helloworld          \"python app.py\"     3 minutes ago       Up 3 minutes        0.0.0.0:5000->80/tcp   dazzling_khayyam\n```\n从输出中可以看到，容器的ID，容器是基于哪个镜像的启动的，容器中的进程，容器的启动时间及端口映射情况。\n\n从现在看，容器已经正确启动，我们使用curl命令通过宿主机的IP和端口号，来访问容器中的web应用：\n```text\ncurl localhost:5000\n<h3>Hello World!</h3><b>Hostname:</b> a242ecaf6cf6<br/>\n```\n还有一种访问容器中应用的方法是使用容器的IP和应用端口号，应用的端口号我们已经在Dockerfile中指定为80，那么容器的IP如何获取呢？\n\n依然是使用`docker inspect CONTAINER ID`命令查看容器的元数据。容器的IP地址就在其中。\n\n## 分享镜像 \n大家一定用过代码分享平台GitHub，在Docker世界中分享镜像的平台是[Docker Hub](https://hub.docker.com/)，它\"学名\"叫镜像仓库（Repository）。\n\n为了能够上传镜像，首先需要注册一个 Docker Hub 账号，然后使用 docker login 命令登录:\n```text\n$ docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: liuchunming\nPassword:\nLogin Succeeded\n```\n在push到Docker Hub之前，需要先给镜像指定一个版本号：\n```text\ndocker tag helloworld liuchunming/helloworld:v1\n```\nliuchunming是我在Docker Hub 上的账户名。v1是我给这个镜像本次起的版本号。\n\n接着执行下面的指令就可以镜像push到Docker Hub上了：\n```text\ndocker push liuchunming/helloworld:v1\n```\n一旦提交到Docker Hub上，其他人就可以通过`docker pull liuchunming/helloworld:v1`指令将镜像下载下来了。\n\n在企业内部，也可以搭建一个跟 Docker Hub 类似的镜像存储系统。感兴趣的话，可以查看VMware 的 Harbor 项目。\n\n## 进入正在运行的容器中玩玩\n运行web服务的容器，通常是以后台进程启动的。就是在`docker run`指令后面加上-d选项。比如以后台方式运行上面的web容器：\n```text\ndocker run -d -p 5000:80 helloworld\n```\n如果你想进入到一个正在运行的容器做一些操作，可以通过`docker exec`指令。我们需要先通过`docker ps`命令查看容器的ID,然后执行下面的命令。\n```text\ndocker exec -it 1695ed10e2cb75e /bin/sh\n```\n-it选项指的是连接到容器后，启动一个terminal(终端)并开启input(输入)功能。`/bin/sh`表示进入到容器后执行的命令。\n\n现在我们就可以在终端上进行一些操作了，比如在容器中新建一个readme.md文件：\n```text\n/app # ps\nPID   USER     TIME  COMMAND\n    1 root      0:00 python app.py\n   24 root      0:00 /bin/sh\n   29 root      0:00 ps\n/app# touch readme.md\n/app# exit\n```\n我们还可以将正在运行的容器，commit成新的镜像。\n```text\ndocker commit 1695ed10e2cb75e liuchunming033/helloworld:v2\n```\ndocker exec 的实现原理，其实是利用了容器的三大核心技术之一的Namespace。一个进程可以选择加入到某个进程（运行中的容器）已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。更细节的原理这里不在细究。\n\n还有一种进入容器的方法是使用`docker attach container_id`，不过这种方法不建议使用，因为它有两个明显的缺点：\n - 当多个窗口同时attach到同一个容器时，所有的窗口都会同步的显示，假如其中的一个窗口发生阻塞时，其它的窗口也会阻塞。\n - attach必须是登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，会导致容器停止。\n\n## 容器与宿主机之间如何共享文件\n容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。但是我们使用过程中经常会遇到这样两个问题：\n\n- 容器里进程新建的文件，怎么才能让宿主机获取到？\n\n- 宿主机上的文件和目录，怎么才能让容器里的进程访问到？\n\n这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改。\n\n在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：\n```text\ndocker run -v /test ...\ndocker run -v /home:/test ...\n```\n而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 /test 目录。\n\n只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 `/var/lib/docker/volumes/[VOLUME_ID]/_data`，然后把它挂载到容器的 /test 目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。\n\n启动容器时，给他声明一个volume\n```text\ndocker run -d -v /test helloworld\n```\n容器启动之后，我们来查看一下这个容器 的Volume 在宿主机上的对应的目录:\n```shell\ndocker volume ls\nDRIVER              VOLUME NAME\nlocal               dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3\n```\n或者执行`docker inspect CONTAINER_ID`命令查看，命令输出的Mounts字段中Source的值就是宿主机上的目录：\n```text\n\"Mounts\": [\n            {\n                \"Type\": \"volume\",\n                \"Name\": \"dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3\",\n                \"Source\": \"/var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\",\n                \"Destination\": \"/test\",\n                \"Driver\": \"local\",\n                \"Mode\": \"\",\n                \"RW\": true,\n                \"Propagation\": \"\"\n            }\n        ],\n```\n然后，查看宿主机上的路径：\n```\nls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\n```\n这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：\n```text\ndocker exec -it cf53b766fa6f /bin/sh\ncd test/\ntouch text.txt\n```\n这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里了：\n```text\nls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data\ntext.txt\n```\n因为容器运行时产生的文件，在容器停止后将会消失。因此，将容器的目录映射到宿主机的某个目录，一个重要使用场景是持久化容器中产生的文件，比如应用的日志。\n\n## 给容器加上资源限制\n其实容器是运行在宿主机上的特殊进程，多个容器之间是共享宿主机的操作系统内核的。默认情况下，容器并没有被设定使用操作系统资源的上限。\n\n有些情况下，我们需要限制容器启动后占用的宿主机操作系统的资源。Docker可以利用Linux Cgroups机制可以给容器设置资源使用限制。\n\nLinux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正是利用这个特性限制容器使用宿主上的CPU、内存。\n\n下面启动容器的方式，给这个 Python 应用加上 CPU 和 Memory 限制：\n```text\ndocker run -it --cpu-period=100000 --cpu-quota=20000 -m 300M helloworld\n```\n--cpu-period和--cpu-quota组合使用来限制容器使用的CPU时间。表示在--cpu-period的一段时间内，容器只能被分配到总量为 --cpu-quota 的 CPU 时间。-m选项则限制了容器使用宿主机内存的上限。\n\n上面启动容器的命令，将容器使用的CPU限制设定在最高20%，内存使用最多是300MB。\n\n## 容器的启动、重启、停止与删除\n前面我们使用过`docker ps` 查看当前运行中的容器，如果加上 -a 选项，则可以查看运行中和已经停止的所有容器。现在，看一下我的系统中目前的所有容器：\n```text\n$ docker ps -a\nCONTAINER ID   IMAGE        COMMAND          CREATED      STATUS                 PORTS                  NAMES\n525a8c3fc769   helloworld   \"python app.py\"  4 hours ago  Up 3 minutes           80/tcp                 hardcore_feistel\n1695ed10e2cb   helloworld   \"python app.py\"  4 hours ago  Up 3 minutes           0.0.0.0:5000->80/tcp   focused_margulis7\na242ecaf6cf6   helloworld   \"python app.py\"  5 hours ago  Exited (0) 4 hours ago                        dazzling_khayyam\nbe0439b30b2a   helloworld   \"python app.py\"  5 hours ago  Created                                       vigilant_lalande\n```\n从输出中可以看到目前有四个容器，有两个容器处于Up状态，也就是处于运行中的状态，一个容器处于Exited(0)状态，也就是退出状态，一个处于Created状态。\n\n这里补充说明一下docker ps -a的输出结果，一共包含7列数据，分别是 CONTAINER ID、IMAGE、COMMAND、CREATED、STATUS、PORTS和NAMES。 这些列的含义分别如下所示： \n- CONTAINER ID：容器ID，唯一标识容器 \n- IMAGE：创建容器时所用的镜像 \n- COMMAND：在容器最后运行的命令 \n- CREATED：容器创建的时间 \n- STATUS：容器的状态 \n- PORTS：对外开放的端口号 \n- NAMES：容器名（具有唯一性，docker负责命名） \n获取到容器的ID之后，可以对容器的状态进行修改，比如容器1695ed10e2cb进行停止、启动、重启：\n```text\ndocker stop 1695ed10e2cb\ndocker start 1695ed10e2cb\ndocker restart 1695ed10e2cb\n```\n删除容器，有两种操作：\n```text\ndocker rm 1695ed10e2cb\ndocker rm -f 1695ed10e2cb\n```\n不带-f选项，只能删除处于非Up状态的容器，带上-f则可以删除处于任何状态下的容器。\n\nDocker容器状态的流转关系，可以下面这张图：\n![](/img/article/container-status.jpg)\n这张图对容器的生命周期有了清晰的描述，总结了容器各种状态之间是如何转换的。\n\n需要注意一点是容器可以先创建容器，稍后再启动。 也就是可以先执行`docker create` 创建容器（处于 Created 状态），再通过`docker start` 以后台方式启动容器。 docker run 命令实际上是 docker create 和 docker start 的组合。\n\n## 维持容器始终保持运行状态\n\ndocker run指令有一个参数`--restart`，在容器中启动的进程正常退出或发生OOM时， docker 会根据 --restart 的策略判断是否需要重启容器。但如果容器是因为执行 docker stop 或docker kill 退出，则不会自动重启。\n\ndocker支持如下restart策略：\n\n- no – 容器退出时不要自动重启。这个是默认值。\n- on-failure[:max-retries] – 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。\n- always – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启容器，不管容器当时的状态如何。\n- unless-stopped – 不管退出状态码是什么始终重启容器。不过当daemon启动时，如果容器之前已经为停止状态，不启动它。\n\n在每次重启容器之前，不断地增加重启延迟（上一次重启的双倍延迟，从100毫秒开始），来防止影响服务器。这意味着daemon将等待100ms,然后200 ms, 400 ms, 800 ms, 1600 ms等等，直到超过on-failure限制，或执行docker stop或docker rm -f。\n\n如果容器重启成功（容器启动后并运行至少10秒），然后delay重置为默认的100ms。\n\n重启策略示例：\n```text\ndocker run --restart=always 1695ed10e2cb # restart策略为always，使得容器退出时,docker将重启它。并且是无限制次数重启。\ndocker run --restart=on-failure:10 redis #restart策略为on-failure,最大重启次数为10的次。容器以非0状态连续退出超过10次，docker将中断尝试重启这个容器。\n```\n可以通过docker inspect来查看已经尝试重启容器了多少次。例如，获取容器1695ed10e2cb的重启次数:\n```text\ndocker inspect -f \"{{ .RestartCount }}\" 1695ed10e2cb\n```\n或者获取上一次容器重启时间：\n```\ndocker inspect -f \"{{ .State.StartedAt }}\" 1695ed10e2cb\n```\n\n## 总结\n本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。\n","slug":"通过容器化Python web应用了解Docker容器核心功能","published":1,"updated":"2019-05-13T00:11:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5dutbjb0007wf73oszh9tfz","content":"<blockquote>\n<p>本篇文章通过一个典型的Python web应用，带你了解Docker的核心功能。需要依赖一台已经安装了Docker的Linux虚拟机。</p>\n</blockquote>\n<h2 id=\"构建一个镜像\">构建一个镜像</h2>\n<p>首先我们准备一个应用。新建一个本文文件，起名叫 <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>，里面写入下面的内容，实现一个简单的web应用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from flask import Flask</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import os</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">@app.route(&apos;/&apos;)</span><br><span class=\"line\">def hello():</span><br><span class=\"line\">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \\</span><br><span class=\"line\">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;           </span><br><span class=\"line\">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname())</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，使用 Flask 框架启动了一个 Web 服务器，而它唯一的功能是：如果当前环境中有“NAME”这个环境变量，就把它打印在“Hello”后，否则就打印“Hello world”，最后再打印出当前环境的 hostname。<br>\n这个应用的依赖文件requirements.txt存在于与其同级的目录中，内容是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat requirements.txt</span><br><span class=\"line\">Flask</span><br></pre></td></tr></table></figure>\n<p>将这样一个应用在容器中跑起来，需要制作一个容器镜像。Docker提供了一种Dockerfile文件，来描述镜像的构建过程。下面的代码存在于与上面的应用（<a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>）同级目录下的Dockerfile中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用官方提供的python:3.6-alpine镜像，作为我们这个镜像的基础镜像，这样我们的镜像就有了python3.6环境</span><br><span class=\"line\">FROM python:3.6-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"># 将工作目录切换为 /app</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前目录下的所有内容复制到镜像的 /app 下</span><br><span class=\"line\">ADD . /app</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 pip 命令安装这个应用所需要的依赖，RUN 指令就是在容器里执行 shell 命令的意思。</span><br><span class=\"line\">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许外界访问容器的 80 端口</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置环境变量</span><br><span class=\"line\">ENV NAME World</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置容器进程为：python app.py，即：这个 Python 应用的启动命令</span><br><span class=\"line\">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>\n<p>这个Dockerfile文件的内容，描述了我们所要构建的 Docker 镜像。Dockerfile中每一行都是按顺序处理的。这个Dockerfile中用到的指令的具体含义已经在以注释的方式写在了Dockerfile中。</p>\n<p>需要再详细介绍一下CMD指令。CMD指定了<code>python app.py</code>为这个容器启动后执行的进程。因为Dockerfile中使用WORKDIR切换了容器的工作路径是/app，所以 <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 的实际路径是 /app/app.py。CMD [“python”, “<a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”] 等价于 “docker run <imgname> python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”。</imgname></p>\n<p>另外，在使用 Dockerfile 时，还有一种 ENTRYPOINT 指令。它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”。</p>\n<p>默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：<code>/bin/sh -c</code>。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c “python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”，即 CMD 的内容就是 ENTRYPOINT 的参数。正是基于这样的原理，Docker 容器的启动进程为实际为 ENTRYPOINT，而不是 CMD。</p>\n<p>需要注意的是，Dockerfile 里的指令并不都是只在容器内部的操作。就比如 ADD，它指的是把当前目录（即 Dockerfile 所在的目录）里的文件，复制到指定容器内的目录当中。</p>\n<p>根据前面的描述，现在我们的整个应用的目录结构应该如下这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">Dockerfile  app.py   requirements.txt</span><br></pre></td></tr></table></figure>\n<p>现在我们执行下面的指令构建镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t helloworld .</span><br></pre></td></tr></table></figure>\n<p>其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。docker build 会自动加载当前目录下的 Dockerfile 文件，然后按照顺序执行Dockerfile文件中的指令。</p>\n<p>Dockerfile 中的每个指令执行后，都会生成一个对应的镜像层。</p>\n<p>上面的命令执行完成后，就形成了一个镜像。可以通过下面的指令查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image ls</span><br><span class=\"line\"></span><br><span class=\"line\">REPOSITORY    TAG        IMAGE ID      CREATED             SIZE</span><br><span class=\"line\">helloworld    latest     5bacb9617bcf  7 minutes ago       89.8MB</span><br></pre></td></tr></table></figure>\n<p>还可以通过 <code>docker inspect helloworld:latest</code> 查看镜像的元信息。</p>\n<h2 id=\"运行镜像\">运行镜像</h2>\n<p>有了镜像，就可以通过下面的指令来运行容器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:80 helloworld</span><br></pre></td></tr></table></figure>\n<p>在这一句命令中，镜像名 helloworld 后面，什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:80 helloworld python app.py</span><br></pre></td></tr></table></figure>\n<p>如果上面的指令执行后，能够输出下面的内容，则表示容器启动成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class=\"line\">* Environment: production</span><br><span class=\"line\">  WARNING: Do not use the development server in a production environment.</span><br><span class=\"line\">  Use a production WSGI server instead.</span><br><span class=\"line\">* Debug mode: off</span><br><span class=\"line\">* Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>\n<p>可以通过运行<code>docker ps</code>指令，查看运行中的容器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br><span class=\"line\"></span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class=\"line\">a242ecaf6cf6        helloworld          &quot;python app.py&quot;     3 minutes ago       Up 3 minutes        0.0.0.0:5000-&gt;80/tcp   dazzling_khayyam</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看到，容器的ID，容器是基于哪个镜像的启动的，容器中的进程，容器的启动时间及端口映射情况。</p>\n<p>从现在看，容器已经正确启动，我们使用curl命令通过宿主机的IP和端口号，来访问容器中的web应用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl localhost:5000</span><br><span class=\"line\">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; a242ecaf6cf6&lt;br/&gt;</span><br></pre></td></tr></table></figure>\n<p>还有一种访问容器中应用的方法是使用容器的IP和应用端口号，应用的端口号我们已经在Dockerfile中指定为80，那么容器的IP如何获取呢？</p>\n<p>依然是使用<code>docker inspect CONTAINER ID</code>命令查看容器的元数据。容器的IP地址就在其中。</p>\n<h2 id=\"分享镜像\">分享镜像</h2>\n<p>大家一定用过代码分享平台GitHub，在Docker世界中分享镜像的平台是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>，它&quot;学名&quot;叫镜像仓库（Repository）。</p>\n<p>为了能够上传镜像，首先需要注册一个 Docker Hub 账号，然后使用 docker login 命令登录:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker login</span><br><span class=\"line\">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class=\"line\">Username: liuchunming</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded</span><br></pre></td></tr></table></figure>\n<p>在push到Docker Hub之前，需要先给镜像指定一个版本号：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag helloworld liuchunming/helloworld:v1</span><br></pre></td></tr></table></figure>\n<p>liuchunming是我在Docker Hub 上的账户名。v1是我给这个镜像本次起的版本号。</p>\n<p>接着执行下面的指令就可以镜像push到Docker Hub上了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push liuchunming/helloworld:v1</span><br></pre></td></tr></table></figure>\n<p>一旦提交到Docker Hub上，其他人就可以通过<code>docker pull liuchunming/helloworld:v1</code>指令将镜像下载下来了。</p>\n<p>在企业内部，也可以搭建一个跟 Docker Hub 类似的镜像存储系统。感兴趣的话，可以查看VMware 的 Harbor 项目。</p>\n<h2 id=\"进入正在运行的容器中玩玩\">进入正在运行的容器中玩玩</h2>\n<p>运行web服务的容器，通常是以后台进程启动的。就是在<code>docker run</code>指令后面加上-d选项。比如以后台方式运行上面的web容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 5000:80 helloworld</span><br></pre></td></tr></table></figure>\n<p>如果你想进入到一个正在运行的容器做一些操作，可以通过<code>docker exec</code>指令。我们需要先通过<code>docker ps</code>命令查看容器的ID,然后执行下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 1695ed10e2cb75e /bin/sh</span><br></pre></td></tr></table></figure>\n<p>-it选项指的是连接到容器后，启动一个terminal(终端)并开启input(输入)功能。<code>/bin/sh</code>表示进入到容器后执行的命令。</p>\n<p>现在我们就可以在终端上进行一些操作了，比如在容器中新建一个readme.md文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/app # ps</span><br><span class=\"line\">PID   USER     TIME  COMMAND</span><br><span class=\"line\">    1 root      0:00 python app.py</span><br><span class=\"line\">   24 root      0:00 /bin/sh</span><br><span class=\"line\">   29 root      0:00 ps</span><br><span class=\"line\">/app# touch readme.md</span><br><span class=\"line\">/app# exit</span><br></pre></td></tr></table></figure>\n<p>我们还可以将正在运行的容器，commit成新的镜像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit 1695ed10e2cb75e liuchunming033/helloworld:v2</span><br></pre></td></tr></table></figure>\n<p>docker exec 的实现原理，其实是利用了容器的三大核心技术之一的Namespace。一个进程可以选择加入到某个进程（运行中的容器）已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。更细节的原理这里不在细究。</p>\n<p>还有一种进入容器的方法是使用<code>docker attach container_id</code>，不过这种方法不建议使用，因为它有两个明显的缺点：</p>\n<ul>\n<li>当多个窗口同时attach到同一个容器时，所有的窗口都会同步的显示，假如其中的一个窗口发生阻塞时，其它的窗口也会阻塞。</li>\n<li>attach必须是登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，会导致容器停止。</li>\n</ul>\n<h2 id=\"容器与宿主机之间如何共享文件\">容器与宿主机之间如何共享文件</h2>\n<p>容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。但是我们使用过程中经常会遇到这样两个问题：</p>\n<ul>\n<li>\n<p>容器里进程新建的文件，怎么才能让宿主机获取到？</p>\n</li>\n<li>\n<p>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</p>\n</li>\n</ul>\n<p>这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改。</p>\n<p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /test ...</span><br><span class=\"line\">docker run -v /home:/test ...</span><br></pre></td></tr></table></figure>\n<p>而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 /test 目录。</p>\n<p>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 <code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>，然后把它挂载到容器的 /test 目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。</p>\n<p>启动容器时，给他声明一个volume</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -v /test helloworld</span><br></pre></td></tr></table></figure>\n<p>容器启动之后，我们来查看一下这个容器 的Volume 在宿主机上的对应的目录:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume ls</span><br><span class=\"line\">DRIVER              VOLUME NAME</span><br><span class=\"line\">local               dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3</span><br></pre></td></tr></table></figure>\n<p>或者执行<code>docker inspect CONTAINER_ID</code>命令查看，命令输出的Mounts字段中Source的值就是宿主机上的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;Mounts&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class=\"line\">                &quot;Name&quot;: &quot;dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3&quot;,</span><br><span class=\"line\">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data&quot;,</span><br><span class=\"line\">                &quot;Destination&quot;: &quot;/test&quot;,</span><br><span class=\"line\">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class=\"line\">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class=\"line\">                &quot;RW&quot;: true,</span><br><span class=\"line\">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ],</span><br></pre></td></tr></table></figure>\n<p>然后，查看宿主机上的路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data</span><br></pre></td></tr></table></figure>\n<p>这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it cf53b766fa6f /bin/sh</span><br><span class=\"line\">cd test/</span><br><span class=\"line\">touch text.txt</span><br></pre></td></tr></table></figure>\n<p>这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data</span><br><span class=\"line\">text.txt</span><br></pre></td></tr></table></figure>\n<p>因为容器运行时产生的文件，在容器停止后将会消失。因此，将容器的目录映射到宿主机的某个目录，一个重要使用场景是持久化容器中产生的文件，比如应用的日志。</p>\n<h2 id=\"给容器加上资源限制\">给容器加上资源限制</h2>\n<p>其实容器是运行在宿主机上的特殊进程，多个容器之间是共享宿主机的操作系统内核的。默认情况下，容器并没有被设定使用操作系统资源的上限。</p>\n<p>有些情况下，我们需要限制容器启动后占用的宿主机操作系统的资源。Docker可以利用Linux Cgroups机制可以给容器设置资源使用限制。</p>\n<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正是利用这个特性限制容器使用宿主上的CPU、内存。</p>\n<p>下面启动容器的方式，给这个 Python 应用加上 CPU 和 Memory 限制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --cpu-period=100000 --cpu-quota=20000 -m 300M helloworld</span><br></pre></td></tr></table></figure>\n<p>–cpu-period和–cpu-quota组合使用来限制容器使用的CPU时间。表示在–cpu-period的一段时间内，容器只能被分配到总量为 --cpu-quota 的 CPU 时间。-m选项则限制了容器使用宿主机内存的上限。</p>\n<p>上面启动容器的命令，将容器使用的CPU限制设定在最高20%，内存使用最多是300MB。</p>\n<h2 id=\"容器的启动-重启-停止与删除\">容器的启动、重启、停止与删除</h2>\n<p>前面我们使用过<code>docker ps</code> 查看当前运行中的容器，如果加上 -a 选项，则可以查看运行中和已经停止的所有容器。现在，看一下我的系统中目前的所有容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps -a</span><br><span class=\"line\">CONTAINER ID   IMAGE        COMMAND          CREATED      STATUS                 PORTS                  NAMES</span><br><span class=\"line\">525a8c3fc769   helloworld   &quot;python app.py&quot;  4 hours ago  Up 3 minutes           80/tcp                 hardcore_feistel</span><br><span class=\"line\">1695ed10e2cb   helloworld   &quot;python app.py&quot;  4 hours ago  Up 3 minutes           0.0.0.0:5000-&gt;80/tcp   focused_margulis7</span><br><span class=\"line\">a242ecaf6cf6   helloworld   &quot;python app.py&quot;  5 hours ago  Exited (0) 4 hours ago                        dazzling_khayyam</span><br><span class=\"line\">be0439b30b2a   helloworld   &quot;python app.py&quot;  5 hours ago  Created                                       vigilant_lalande</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看到目前有四个容器，有两个容器处于Up状态，也就是处于运行中的状态，一个容器处于Exited(0)状态，也就是退出状态，一个处于Created状态。</p>\n<p>这里补充说明一下docker ps -a的输出结果，一共包含7列数据，分别是 CONTAINER ID、IMAGE、COMMAND、CREATED、STATUS、PORTS和NAMES。 这些列的含义分别如下所示：</p>\n<ul>\n<li>CONTAINER ID：容器ID，唯一标识容器</li>\n<li>IMAGE：创建容器时所用的镜像</li>\n<li>COMMAND：在容器最后运行的命令</li>\n<li>CREATED：容器创建的时间</li>\n<li>STATUS：容器的状态</li>\n<li>PORTS：对外开放的端口号</li>\n<li>NAMES：容器名（具有唯一性，docker负责命名）<br>\n获取到容器的ID之后，可以对容器的状态进行修改，比如容器1695ed10e2cb进行停止、启动、重启：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 1695ed10e2cb</span><br><span class=\"line\">docker start 1695ed10e2cb</span><br><span class=\"line\">docker restart 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>删除容器，有两种操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm 1695ed10e2cb</span><br><span class=\"line\">docker rm -f 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>不带-f选项，只能删除处于非Up状态的容器，带上-f则可以删除处于任何状态下的容器。</p>\n<p>Docker容器状态的流转关系，可以下面这张图：<br>\n<img src=\"/img/article/container-status.jpg\" alt=\"\"><br>\n这张图对容器的生命周期有了清晰的描述，总结了容器各种状态之间是如何转换的。</p>\n<p>需要注意一点是容器可以先创建容器，稍后再启动。 也就是可以先执行<code>docker create</code> 创建容器（处于 Created 状态），再通过<code>docker start</code> 以后台方式启动容器。 docker run 命令实际上是 docker create 和 docker start 的组合。</p>\n<h2 id=\"维持容器始终保持运行状态\">维持容器始终保持运行状态</h2>\n<p>docker run指令有一个参数<code>--restart</code>，在容器中启动的进程正常退出或发生OOM时， docker 会根据 --restart 的策略判断是否需要重启容器。但如果容器是因为执行 docker stop 或docker kill 退出，则不会自动重启。</p>\n<p>docker支持如下restart策略：</p>\n<ul>\n<li>no – 容器退出时不要自动重启。这个是默认值。</li>\n<li>on-failure[:max-retries] – 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。</li>\n<li>always – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启容器，不管容器当时的状态如何。</li>\n<li>unless-stopped – 不管退出状态码是什么始终重启容器。不过当daemon启动时，如果容器之前已经为停止状态，不启动它。</li>\n</ul>\n<p>在每次重启容器之前，不断地增加重启延迟（上一次重启的双倍延迟，从100毫秒开始），来防止影响服务器。这意味着daemon将等待100ms,然后200 ms, 400 ms, 800 ms, 1600 ms等等，直到超过on-failure限制，或执行docker stop或docker rm -f。</p>\n<p>如果容器重启成功（容器启动后并运行至少10秒），然后delay重置为默认的100ms。</p>\n<p>重启策略示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always 1695ed10e2cb # restart策略为always，使得容器退出时,docker将重启它。并且是无限制次数重启。</span><br><span class=\"line\">docker run --restart=on-failure:10 redis #restart策略为on-failure,最大重启次数为10的次。容器以非0状态连续退出超过10次，docker将中断尝试重启这个容器。</span><br></pre></td></tr></table></figure>\n<p>可以通过docker inspect来查看已经尝试重启容器了多少次。例如，获取容器1695ed10e2cb的重启次数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>或者获取上一次容器重启时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\">总结</h2>\n<p>本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本篇文章通过一个典型的Python web应用，带你了解Docker的核心功能。需要依赖一台已经安装了Docker的Linux虚拟机。</p>\n</blockquote>\n<h2>构建一个镜像</h2>\n<p>首先我们准备一个应用。新建一个本文文件，起名叫 <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>，里面写入下面的内容，实现一个简单的web应用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from flask import Flask</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import os</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\">@app.route(&apos;/&apos;)</span><br><span class=\"line\">def hello():</span><br><span class=\"line\">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \\</span><br><span class=\"line\">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;           </span><br><span class=\"line\">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname())</span><br><span class=\"line\">    </span><br><span class=\"line\">if __name__ == &quot;__main__&quot;:</span><br><span class=\"line\">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br></pre></td></tr></table></figure>\n<p>在这段代码中，使用 Flask 框架启动了一个 Web 服务器，而它唯一的功能是：如果当前环境中有“NAME”这个环境变量，就把它打印在“Hello”后，否则就打印“Hello world”，最后再打印出当前环境的 hostname。<br>\n这个应用的依赖文件requirements.txt存在于与其同级的目录中，内容是：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat requirements.txt</span><br><span class=\"line\">Flask</span><br></pre></td></tr></table></figure>\n<p>将这样一个应用在容器中跑起来，需要制作一个容器镜像。Docker提供了一种Dockerfile文件，来描述镜像的构建过程。下面的代码存在于与上面的应用（<a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>）同级目录下的Dockerfile中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用官方提供的python:3.6-alpine镜像，作为我们这个镜像的基础镜像，这样我们的镜像就有了python3.6环境</span><br><span class=\"line\">FROM python:3.6-alpine</span><br><span class=\"line\"></span><br><span class=\"line\"># 将工作目录切换为 /app</span><br><span class=\"line\">WORKDIR /app</span><br><span class=\"line\"></span><br><span class=\"line\"># 将当前目录下的所有内容复制到镜像的 /app 下</span><br><span class=\"line\">ADD . /app</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用 pip 命令安装这个应用所需要的依赖，RUN 指令就是在容器里执行 shell 命令的意思。</span><br><span class=\"line\">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class=\"line\"></span><br><span class=\"line\"># 允许外界访问容器的 80 端口</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置环境变量</span><br><span class=\"line\">ENV NAME World</span><br><span class=\"line\"></span><br><span class=\"line\"># 设置容器进程为：python app.py，即：这个 Python 应用的启动命令</span><br><span class=\"line\">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>\n<p>这个Dockerfile文件的内容，描述了我们所要构建的 Docker 镜像。Dockerfile中每一行都是按顺序处理的。这个Dockerfile中用到的指令的具体含义已经在以注释的方式写在了Dockerfile中。</p>\n<p>需要再详细介绍一下CMD指令。CMD指定了<code>python app.py</code>为这个容器启动后执行的进程。因为Dockerfile中使用WORKDIR切换了容器的工作路径是/app，所以 <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a> 的实际路径是 /app/app.py。CMD [“python”, “<a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”] 等价于 “docker run <imgname> python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”。</imgname></p>\n<p>另外，在使用 Dockerfile 时，还有一种 ENTRYPOINT 指令。它和 CMD 都是 Docker 容器进程启动所必需的参数，完整执行格式是：“ENTRYPOINT CMD”。</p>\n<p>默认情况下，Docker 会为你提供一个隐含的 ENTRYPOINT，即：<code>/bin/sh -c</code>。所以，在不指定 ENTRYPOINT 时，比如在我们这个例子里，实际上运行在容器里的完整进程是：/bin/sh -c “python <a href=\"http://app.py\" target=\"_blank\" rel=\"noopener\">app.py</a>”，即 CMD 的内容就是 ENTRYPOINT 的参数。正是基于这样的原理，Docker 容器的启动进程为实际为 ENTRYPOINT，而不是 CMD。</p>\n<p>需要注意的是，Dockerfile 里的指令并不都是只在容器内部的操作。就比如 ADD，它指的是把当前目录（即 Dockerfile 所在的目录）里的文件，复制到指定容器内的目录当中。</p>\n<p>根据前面的描述，现在我们的整个应用的目录结构应该如下这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br><span class=\"line\">Dockerfile  app.py   requirements.txt</span><br></pre></td></tr></table></figure>\n<p>现在我们执行下面的指令构建镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t helloworld .</span><br></pre></td></tr></table></figure>\n<p>其中，-t 的作用是给这个镜像加一个 Tag，即：起一个好听的名字。docker build 会自动加载当前目录下的 Dockerfile 文件，然后按照顺序执行Dockerfile文件中的指令。</p>\n<p>Dockerfile 中的每个指令执行后，都会生成一个对应的镜像层。</p>\n<p>上面的命令执行完成后，就形成了一个镜像。可以通过下面的指令查看：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image ls</span><br><span class=\"line\"></span><br><span class=\"line\">REPOSITORY    TAG        IMAGE ID      CREATED             SIZE</span><br><span class=\"line\">helloworld    latest     5bacb9617bcf  7 minutes ago       89.8MB</span><br></pre></td></tr></table></figure>\n<p>还可以通过 <code>docker inspect helloworld:latest</code> 查看镜像的元信息。</p>\n<h2>运行镜像</h2>\n<p>有了镜像，就可以通过下面的指令来运行容器了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:80 helloworld</span><br></pre></td></tr></table></figure>\n<p>在这一句命令中，镜像名 helloworld 后面，什么都不用写，因为在 Dockerfile 中已经指定了 CMD。否则，我就得把进程的启动命令加在后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 5000:80 helloworld python app.py</span><br></pre></td></tr></table></figure>\n<p>如果上面的指令执行后，能够输出下面的内容，则表示容器启动成功了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class=\"line\">* Environment: production</span><br><span class=\"line\">  WARNING: Do not use the development server in a production environment.</span><br><span class=\"line\">  Use a production WSGI server instead.</span><br><span class=\"line\">* Debug mode: off</span><br><span class=\"line\">* Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>\n<p>可以通过运行<code>docker ps</code>指令，查看运行中的容器。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br><span class=\"line\"></span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                  NAMES</span><br><span class=\"line\">a242ecaf6cf6        helloworld          &quot;python app.py&quot;     3 minutes ago       Up 3 minutes        0.0.0.0:5000-&gt;80/tcp   dazzling_khayyam</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看到，容器的ID，容器是基于哪个镜像的启动的，容器中的进程，容器的启动时间及端口映射情况。</p>\n<p>从现在看，容器已经正确启动，我们使用curl命令通过宿主机的IP和端口号，来访问容器中的web应用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl localhost:5000</span><br><span class=\"line\">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; a242ecaf6cf6&lt;br/&gt;</span><br></pre></td></tr></table></figure>\n<p>还有一种访问容器中应用的方法是使用容器的IP和应用端口号，应用的端口号我们已经在Dockerfile中指定为80，那么容器的IP如何获取呢？</p>\n<p>依然是使用<code>docker inspect CONTAINER ID</code>命令查看容器的元数据。容器的IP地址就在其中。</p>\n<h2>分享镜像</h2>\n<p>大家一定用过代码分享平台GitHub，在Docker世界中分享镜像的平台是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>，它&quot;学名&quot;叫镜像仓库（Repository）。</p>\n<p>为了能够上传镜像，首先需要注册一个 Docker Hub 账号，然后使用 docker login 命令登录:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker login</span><br><span class=\"line\">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class=\"line\">Username: liuchunming</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded</span><br></pre></td></tr></table></figure>\n<p>在push到Docker Hub之前，需要先给镜像指定一个版本号：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag helloworld liuchunming/helloworld:v1</span><br></pre></td></tr></table></figure>\n<p>liuchunming是我在Docker Hub 上的账户名。v1是我给这个镜像本次起的版本号。</p>\n<p>接着执行下面的指令就可以镜像push到Docker Hub上了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker push liuchunming/helloworld:v1</span><br></pre></td></tr></table></figure>\n<p>一旦提交到Docker Hub上，其他人就可以通过<code>docker pull liuchunming/helloworld:v1</code>指令将镜像下载下来了。</p>\n<p>在企业内部，也可以搭建一个跟 Docker Hub 类似的镜像存储系统。感兴趣的话，可以查看VMware 的 Harbor 项目。</p>\n<h2>进入正在运行的容器中玩玩</h2>\n<p>运行web服务的容器，通常是以后台进程启动的。就是在<code>docker run</code>指令后面加上-d选项。比如以后台方式运行上面的web容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -p 5000:80 helloworld</span><br></pre></td></tr></table></figure>\n<p>如果你想进入到一个正在运行的容器做一些操作，可以通过<code>docker exec</code>指令。我们需要先通过<code>docker ps</code>命令查看容器的ID,然后执行下面的命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it 1695ed10e2cb75e /bin/sh</span><br></pre></td></tr></table></figure>\n<p>-it选项指的是连接到容器后，启动一个terminal(终端)并开启input(输入)功能。<code>/bin/sh</code>表示进入到容器后执行的命令。</p>\n<p>现在我们就可以在终端上进行一些操作了，比如在容器中新建一个readme.md文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/app # ps</span><br><span class=\"line\">PID   USER     TIME  COMMAND</span><br><span class=\"line\">    1 root      0:00 python app.py</span><br><span class=\"line\">   24 root      0:00 /bin/sh</span><br><span class=\"line\">   29 root      0:00 ps</span><br><span class=\"line\">/app# touch readme.md</span><br><span class=\"line\">/app# exit</span><br></pre></td></tr></table></figure>\n<p>我们还可以将正在运行的容器，commit成新的镜像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker commit 1695ed10e2cb75e liuchunming033/helloworld:v2</span><br></pre></td></tr></table></figure>\n<p>docker exec 的实现原理，其实是利用了容器的三大核心技术之一的Namespace。一个进程可以选择加入到某个进程（运行中的容器）已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。更细节的原理这里不在细究。</p>\n<p>还有一种进入容器的方法是使用<code>docker attach container_id</code>，不过这种方法不建议使用，因为它有两个明显的缺点：</p>\n<ul>\n<li>当多个窗口同时attach到同一个容器时，所有的窗口都会同步的显示，假如其中的一个窗口发生阻塞时，其它的窗口也会阻塞。</li>\n<li>attach必须是登陆到一个已经运行的容器里，如果从这个容器中exit退出的话，会导致容器停止。</li>\n</ul>\n<h2>容器与宿主机之间如何共享文件</h2>\n<p>容器技术使用了 rootfs 机制和 Mount Namespace，构建出了一个同宿主机完全隔离开的文件系统环境。但是我们使用过程中经常会遇到这样两个问题：</p>\n<ul>\n<li>\n<p>容器里进程新建的文件，怎么才能让宿主机获取到？</p>\n</li>\n<li>\n<p>宿主机上的文件和目录，怎么才能让容器里的进程访问到？</p>\n</li>\n</ul>\n<p>这正是 Docker Volume 要解决的问题：Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改。</p>\n<p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目录当中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -v /test ...</span><br><span class=\"line\">docker run -v /home:/test ...</span><br></pre></td></tr></table></figure>\n<p>而这两种声明方式的本质，实际上是相同的：都是把一个宿主机的目录挂载进了容器的 /test 目录。</p>\n<p>只不过，在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机上创建一个临时目录 <code>/var/lib/docker/volumes/[VOLUME_ID]/_data</code>，然后把它挂载到容器的 /test 目录上。而在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。</p>\n<p>启动容器时，给他声明一个volume</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -d -v /test helloworld</span><br></pre></td></tr></table></figure>\n<p>容器启动之后，我们来查看一下这个容器 的Volume 在宿主机上的对应的目录:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker volume ls</span><br><span class=\"line\">DRIVER              VOLUME NAME</span><br><span class=\"line\">local               dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3</span><br></pre></td></tr></table></figure>\n<p>或者执行<code>docker inspect CONTAINER_ID</code>命令查看，命令输出的Mounts字段中Source的值就是宿主机上的目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;Mounts&quot;: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class=\"line\">                &quot;Name&quot;: &quot;dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3&quot;,</span><br><span class=\"line\">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data&quot;,</span><br><span class=\"line\">                &quot;Destination&quot;: &quot;/test&quot;,</span><br><span class=\"line\">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class=\"line\">                &quot;Mode&quot;: &quot;&quot;,</span><br><span class=\"line\">                &quot;RW&quot;: true,</span><br><span class=\"line\">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ],</span><br></pre></td></tr></table></figure>\n<p>然后，查看宿主机上的路径：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data</span><br></pre></td></tr></table></figure>\n<p>这个 _data 文件夹，就是这个容器的 Volume 在宿主机上对应的临时目录了。接下来，我们在容器的 Volume 里，添加一个文件 text.txt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it cf53b766fa6f /bin/sh</span><br><span class=\"line\">cd test/</span><br><span class=\"line\">touch text.txt</span><br></pre></td></tr></table></figure>\n<p>这时，我们再回到宿主机，就会发现 text.txt 已经出现在了宿主机上对应的临时目录里了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls /var/lib/docker/volumes/dc195c8ad14ad505832461d9f37da889c54ef284ebaf777a100e10a932217ad3/_data</span><br><span class=\"line\">text.txt</span><br></pre></td></tr></table></figure>\n<p>因为容器运行时产生的文件，在容器停止后将会消失。因此，将容器的目录映射到宿主机的某个目录，一个重要使用场景是持久化容器中产生的文件，比如应用的日志。</p>\n<h2>给容器加上资源限制</h2>\n<p>其实容器是运行在宿主机上的特殊进程，多个容器之间是共享宿主机的操作系统内核的。默认情况下，容器并没有被设定使用操作系统资源的上限。</p>\n<p>有些情况下，我们需要限制容器启动后占用的宿主机操作系统的资源。Docker可以利用Linux Cgroups机制可以给容器设置资源使用限制。</p>\n<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。Docker正是利用这个特性限制容器使用宿主上的CPU、内存。</p>\n<p>下面启动容器的方式，给这个 Python 应用加上 CPU 和 Memory 限制：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --cpu-period=100000 --cpu-quota=20000 -m 300M helloworld</span><br></pre></td></tr></table></figure>\n<p>–cpu-period和–cpu-quota组合使用来限制容器使用的CPU时间。表示在–cpu-period的一段时间内，容器只能被分配到总量为 --cpu-quota 的 CPU 时间。-m选项则限制了容器使用宿主机内存的上限。</p>\n<p>上面启动容器的命令，将容器使用的CPU限制设定在最高20%，内存使用最多是300MB。</p>\n<h2>容器的启动、重启、停止与删除</h2>\n<p>前面我们使用过<code>docker ps</code> 查看当前运行中的容器，如果加上 -a 选项，则可以查看运行中和已经停止的所有容器。现在，看一下我的系统中目前的所有容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ docker ps -a</span><br><span class=\"line\">CONTAINER ID   IMAGE        COMMAND          CREATED      STATUS                 PORTS                  NAMES</span><br><span class=\"line\">525a8c3fc769   helloworld   &quot;python app.py&quot;  4 hours ago  Up 3 minutes           80/tcp                 hardcore_feistel</span><br><span class=\"line\">1695ed10e2cb   helloworld   &quot;python app.py&quot;  4 hours ago  Up 3 minutes           0.0.0.0:5000-&gt;80/tcp   focused_margulis7</span><br><span class=\"line\">a242ecaf6cf6   helloworld   &quot;python app.py&quot;  5 hours ago  Exited (0) 4 hours ago                        dazzling_khayyam</span><br><span class=\"line\">be0439b30b2a   helloworld   &quot;python app.py&quot;  5 hours ago  Created                                       vigilant_lalande</span><br></pre></td></tr></table></figure>\n<p>从输出中可以看到目前有四个容器，有两个容器处于Up状态，也就是处于运行中的状态，一个容器处于Exited(0)状态，也就是退出状态，一个处于Created状态。</p>\n<p>这里补充说明一下docker ps -a的输出结果，一共包含7列数据，分别是 CONTAINER ID、IMAGE、COMMAND、CREATED、STATUS、PORTS和NAMES。 这些列的含义分别如下所示：</p>\n<ul>\n<li>CONTAINER ID：容器ID，唯一标识容器</li>\n<li>IMAGE：创建容器时所用的镜像</li>\n<li>COMMAND：在容器最后运行的命令</li>\n<li>CREATED：容器创建的时间</li>\n<li>STATUS：容器的状态</li>\n<li>PORTS：对外开放的端口号</li>\n<li>NAMES：容器名（具有唯一性，docker负责命名）<br>\n获取到容器的ID之后，可以对容器的状态进行修改，比如容器1695ed10e2cb进行停止、启动、重启：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop 1695ed10e2cb</span><br><span class=\"line\">docker start 1695ed10e2cb</span><br><span class=\"line\">docker restart 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>删除容器，有两种操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm 1695ed10e2cb</span><br><span class=\"line\">docker rm -f 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>不带-f选项，只能删除处于非Up状态的容器，带上-f则可以删除处于任何状态下的容器。</p>\n<p>Docker容器状态的流转关系，可以下面这张图：<br>\n<img src=\"/img/article/container-status.jpg\" alt=\"\"><br>\n这张图对容器的生命周期有了清晰的描述，总结了容器各种状态之间是如何转换的。</p>\n<p>需要注意一点是容器可以先创建容器，稍后再启动。 也就是可以先执行<code>docker create</code> 创建容器（处于 Created 状态），再通过<code>docker start</code> 以后台方式启动容器。 docker run 命令实际上是 docker create 和 docker start 的组合。</p>\n<h2>维持容器始终保持运行状态</h2>\n<p>docker run指令有一个参数<code>--restart</code>，在容器中启动的进程正常退出或发生OOM时， docker 会根据 --restart 的策略判断是否需要重启容器。但如果容器是因为执行 docker stop 或docker kill 退出，则不会自动重启。</p>\n<p>docker支持如下restart策略：</p>\n<ul>\n<li>no – 容器退出时不要自动重启。这个是默认值。</li>\n<li>on-failure[:max-retries] – 只在容器以非0状态码退出时重启。可选的，可以退出docker daemon尝试重启容器的次数。</li>\n<li>always – 不管退出状态码是什么始终重启容器。当指定always时，docker daemon将无限次数地重启容器。容器也会在daemon启动时尝试重启容器，不管容器当时的状态如何。</li>\n<li>unless-stopped – 不管退出状态码是什么始终重启容器。不过当daemon启动时，如果容器之前已经为停止状态，不启动它。</li>\n</ul>\n<p>在每次重启容器之前，不断地增加重启延迟（上一次重启的双倍延迟，从100毫秒开始），来防止影响服务器。这意味着daemon将等待100ms,然后200 ms, 400 ms, 800 ms, 1600 ms等等，直到超过on-failure限制，或执行docker stop或docker rm -f。</p>\n<p>如果容器重启成功（容器启动后并运行至少10秒），然后delay重置为默认的100ms。</p>\n<p>重启策略示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run --restart=always 1695ed10e2cb # restart策略为always，使得容器退出时,docker将重启它。并且是无限制次数重启。</span><br><span class=\"line\">docker run --restart=on-failure:10 redis #restart策略为on-failure,最大重启次数为10的次。容器以非0状态连续退出超过10次，docker将中断尝试重启这个容器。</span><br></pre></td></tr></table></figure>\n<p>可以通过docker inspect来查看已经尝试重启容器了多少次。例如，获取容器1695ed10e2cb的重启次数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect -f &quot;&#123;&#123; .RestartCount &#125;&#125;&quot; 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<p>或者获取上一次容器重启时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker inspect -f &quot;&#123;&#123; .State.StartedAt &#125;&#125;&quot; 1695ed10e2cb</span><br></pre></td></tr></table></figure>\n<h2>总结</h2>\n<p>本篇文章通过非常经典的 Python web应用作为案例，讲解了 Docker 容器使用的主要场景。包括构建镜像、启动镜像、分享镜像、在镜像中操作、在镜像中挂载宿主机目录、对容器使用的资源进行限制、管理容器的状态和如何保持容器始终运行。熟悉了这些操作，你也就基本上摸清了 Docker 容器的核心功能。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck5dutbj00001wf738yzi1kmd","tag_id":"ck5dutbj70005wf73irgx3x6i","_id":"ck5dutbje0009wf73ptgw6gfj"},{"post_id":"ck5dutbj50003wf73kon5dq03","tag_id":"ck5dutbjd0008wf73s7jtgpeo","_id":"ck5dutbjf000bwf737ur4q5sv"},{"post_id":"ck5dutbj90006wf73m83dg8x4","tag_id":"ck5dutbjf000awf73ntlio39i","_id":"ck5dutbjj000dwf731pn9cm26"},{"post_id":"ck5dutbjb0007wf73oszh9tfz","tag_id":"ck5dutbjd0008wf73s7jtgpeo","_id":"ck5dutbjk000ewf73u53ldfc3"}],"Tag":[{"name":"Hexo","_id":"ck5dutbj70005wf73irgx3x6i"},{"name":"Docker","_id":"ck5dutbjd0008wf73s7jtgpeo"},{"name":"软件测试","_id":"ck5dutbjf000awf73ntlio39i"}]}}